<?phpclass Inventory_AssemblyExplode extends Inventory_InventoryBase{    public $Show_Query                  = false;    public $Use_Fake_Build              = false;            public $Barcode                     = 0;    public $Quantity                    = 1;        public $BOM                         = array();      // variable the calling functin should access (RETURN from class)        public function  __construct()    {        parent::__construct();        $this->SetSQLInventory();   // set the database connection to the inventory database                $this->Classname = get_class($this);        $this->ClassInfo = array(            'Created By'    => 'Richard Witherspoon',            'Created Date'  => '2013-01-14',            'Updated By'    => 'Richard Witherspoon',            'Updated Date'  => '2013-02-11',            'Filename'      => $this->Classname,            'Version'       => '1.2',            'Description'   => 'Take an assembly and determine all of its raw inventory items.',            'Update Log'    => array(                '2013-01-14_1.0'    => "Module Created",                '2013-02-07_1.1'    => "Updates to GetAssembly_BuildRecord() and GetInventoryAssembliesFromBarcode() to provide barcode and quantity information",                '2013-02-11_1.2'    => "Disabled use of AddQtyInformationToAssemblyArray() function - was creating infinite loop. Must keep inventory_in and inventory_out seperate in array",            ),        );            } // -------------- END __construct --------------            /* ===== P-CODE =============================        Get build record from database fort his barcode    Loop through build record and determine if its raw inventory or a sub-ASSY    If sub-ASSY - get that record        return an array of barcodes and quantities for build record        ========================================== */            public function Execute()    {        //echo "<div style='border:5px solid red; padding:10px;'>";                        if (!$this->Barcode)   {   echo "<br />ERROR :: {$this->Classname} :: Execute() :: Missing Barcode"; exit();  }                        // ===== GET THE BUILD RECORD =====        if ($this->Use_Fake_Build) {            $this->EchoVar('NOTICE', "{$this->Classname} :: Execute() :: Using a fake build record", 'Red');            $this->Quantity = 10;            $build_record = $this->FakeBuildRecord();        } else {                        if (false) {                $sku = $this->GetInventoryRecordFromBarcode($this->Barcode);                $sku = $sku['retailer_code'];                                $this->EchoVar('this->Barcode', $this->Barcode);                $this->EchoVar('sku', $sku);            }                        $build_record   = $this->GetAssembly_BuildRecord($this->Barcode);       // get the original build record                        #$this->EchoVar('build_record', $build_record);            #exit();                        $build_record   = $this->ProcessLines($build_record);                   // process lines to determine if there are other sub-assemblies        }                #$this->EchoVar('build_record', $build_record);        #exit();                // ===== PROCESS THE BUILD RECORD =====        $build_record   = $this->CalculateQuantities($build_record, $this->Quantity);       // calculate what the quantities are at each level        $this->SimplifyBuildRecord($build_record);                                          // simplify build record to just barcodes and quantities        $this->RemoveAssemblyFromBuildRecord();                                             // remove any assembly barcodes from the build record                        if ($this->Use_Fake_Build) {            $check_arr = $this->FakeBuildRecordCheck();            if ($check_arr != $this->BOM) {                $this->EchoVar('ERROR', "{$this->Classname} :: Execute() :: Fake build array did not calculate quantities correctly", 'Red');            } else {                echo "<br />success";            }        }                #$this->EchoVar('build_record - AFTER QUANTITIES', $build_record);        #$this->EchoVar('BOM', $this->BOM);            }                public function GetBom_FromBuildRecord($build_record)    {        $build_record   = $this->ProcessLines($build_record);                               // process lines to determine if there are other sub-assemblies        $build_record   = $this->CalculateQuantities($build_record, $this->Quantity);       // calculate what the quantities are at each level        $this->SimplifyBuildRecord($build_record);                                          // simplify build record to just barcodes and quantities        $this->RemoveAssemblyFromBuildRecord();                                             // remove any assembly barcodes from the build record            }                    public function GetAssembly_BuildRecord($barcode)    {        $recs_assy                  = $this->GetInventoryAssembliesFromBarcode($barcode);                   // get all possible assemblies        $inventory_assemblies_id    = $this->GetDefaultInventoryAssembliesID($recs_assy);                   // determine the assembly to use        $records_assembly_lines     = $this->GetAssemblyRecord($inventory_assemblies_id);                   // get the lines used for this assembly                        #$this->EchoVar('recs_assy', $recs_assy);        #$this->EchoVar('inventory_assemblies_id', $inventory_assemblies_id);        #$this->EchoVar('records_assembly_lines', $records_assembly_lines);                        // ----- add master barcode being created to build record - as the first record        $cnt = count($recs_assy);        for ($z=0; $z<$cnt; $z++) {                        $check_id = $recs_assy[$z]['inventory_assemblies_id'];                        #$this->EchoVar('check_id', $check_id);            #$this->EchoVar('inventory_assemblies_id', $inventory_assemblies_id);                        if ($check_id == $inventory_assemblies_id) {                // ----- this is the default record                array_unshift ($records_assembly_lines, array(                    'barcode'       => $recs_assy[0]['barcode'],                     'quantity_out'  => 0,                     'quantity_in'   => $recs_assy[0]['quantity'])                );            }        }                                #$this->EchoVar('records_assembly_lines', $records_assembly_lines);        #exit();                $Obj                        = new Inventory_InventoryAssemblyBuild();                               // instantiate object to convert to build record        $build_record               = $Obj->CreateBuildRecord($records_assembly_lines);                     // create build record        $build_record               = $this->AddSKUInformationToAssemblyArray($build_record);               // add info about the SKU being used        $build_record               = $this->AddSubassemblyToAssemblyArray($build_record);                  // add sub-assembly status to array                return $build_record;    }        public function ProcessLines($ARR)    {        # FUNCTION :: Check each barcode in the BOM and determine if its actually another subassembly        #             which then needs to be pulled - and continue until no more sub-assemblies found.        #             All this function does is build up a complete array of assemblies                foreach ($ARR as $id => $record) {                        $barcode            = $record['barcode'];            $is_subassembly     = isset($record['is_subassembly']) ? $record['is_subassembly'] : 0;                        if ($is_subassembly) {                // ----- This is a sub-assembly so need to go deeper                $build_record           = $this->GetAssembly_BuildRecord($barcode);                $build_record           = $this->ProcessLines($build_record);                $ARR[$id]['assembly']   = $build_record;            }        }                return $ARR;    }        public function CalculateQuantities($ARR, $QTY_PARENT=1)    {        # FUNCTION :: Determine how many of this barcode will be used - based on qty for build and parent qty                foreach ($ARR as $id => $record) {            $quantity = ($record['quantity_out'] * $QTY_PARENT);            $ARR[$id]['quantity_calculated'] = $quantity;                        if (isset($record['assembly'])) {                $ARR_T = $this->CalculateQuantities($record['assembly'], $quantity);        // recursively work lower into the array                $ARR[$id]['assembly'] = $ARR_T;            }        }                return $ARR;    }        public function SimplifyBuildRecord($ARR)    {        # FUNCTION :: Turn a build array into a BOM with just barcodes and total quantities                foreach ($ARR as $id => $record) {                        // ----- Calculate the quantity for this barcode            $barcode                = $record['barcode'];            $quantity               = $record['quantity_calculated'];            $quantity_previous      = (isset($this->BOM[$barcode])) ? $this->BOM[$barcode] : 0;            $this->BOM[$barcode]    = $quantity + $quantity_previous;                                    // ----- recursively check if there are other sub-assemblies to tally            if (isset($record['assembly'])) {                $ARR_T = $this->SimplifyBuildRecord($record['assembly']);            }        }    }        public function RemoveAssemblyFromBuildRecord()    {        # FUNCTION :: Remove barcodes that were assemblies - because their barcodes are already in here                foreach ($this->BOM as $bcode => $qty) {            $is_assembly = $this->CheckIfAssembly($bcode);            if ($is_assembly) {                unset($this->BOM[$bcode]);            }        }    }        public function CheckIfSubAssembly($barcode)    {        // Check if this item is a sub-assembly                $records = $this->SQL->GetArrayAll(array(            'table' => 'inventory_assemblies',            'keys'  => 'inventory_assemblies_id',            'where' => "barcode='{$barcode}' AND active=1"        ));        $this->EchoQuery();                $is_subassembly = ($records) ? 1 : 0;        return $is_subassembly;    }        public function _AddQtyInformationToAssemblyArray($ARR)    {        # FUNCTION :: Add quantity information to the array        foreach ($ARR as $id => $record) {            $quantity               = ($record['quantity_out'] + $record['quantity_in']);       // can't have both in and out so this gives real total            $ARR[$id]['quantity']   = $quantity;                        unset($ARR[$id]['quantity_out']);            unset($ARR[$id]['quantity_in']);        }                return $ARR;    }        public function AddSubassemblyToAssemblyArray($ARR)    {        # FUNCTION :: Add sub-assembly information to each record        foreach ($ARR as $id => $record) {            $is_subassembly = $this->CheckIfSubAssembly($record['barcode']);                        if ($record['quantity_in'] != 0) {                $ARR[$id]['is_subassembly'] = 0;  // don't mark subassembly for the master item            } else {                $ARR[$id]['is_subassembly'] = $is_subassembly;            }        }                return $ARR;    }        public function AddSKUInformationToAssemblyArray($ARR)    {        # FUNCTION :: Add SKU information to the array        foreach ($ARR as $id => $record) {            $ARR[$id]['sku']            = $this->GetInventoryItemRetailerCodeFromBarcode($record['barcode']);            //$ARR[$id]['description']    = $rec['description'];        }                return $ARR;    }        public function GetAssemblyRecord($inventory_assemblies_id)    {        $records = $this->SQL->GetArrayAll(array(            'table' => " inventory_assembly_lines",            'keys'  => "*",            'where' => "`inventory_assemblies_id`='{$inventory_assemblies_id}' AND active=1",        ));        $this->EchoQuery();        return $records;    }        public function GetInventoryAssembliesFromBarcode($barcode)    {        # Note : default must be wrapped in tick marks or query will fail - its a protected MySQL word                $records = $this->SQL->GetArrayAll(array(            'table' => 'inventory_assemblies',            'keys'  => 'inventory_assemblies_id, `default`, barcode, quantity',            'where' => "barcode='{$barcode}' AND active=1",        ));        $this->EchoQuery();        return $records;    }            public function GetDefaultInventoryAssembliesID($ARR)    {        // ----- multiple build records for this barcode - determine the default build to use        // ----- will use the first record found if no default        $default_id     = 0;        $default_found  = false;        if (count($ARR) > 1) {            foreach ($ARR as $id2 => $rec_assy_build) {                if ($rec_assy_build['default'] == 1) {                                        // ----- check for multiple defaults                    if ($default_found == true) {                        echo "<br />ERROR :: Inventory_InventoryAssemblyCalculateValue :: ProcessLines() :: Multiple default assemblies found";                        exit();                    }                                        $default_id     = $id2; //$rec_assy_build['inventory_assemblies_id'];                    $default_found  = true;                }            }            //$this->EchoVar('ARR', $ARR);        }                $inventory_assemblies_id    = $ARR[$default_id]['inventory_assemblies_id'];        return $inventory_assemblies_id;    }        public function CheckIfAssembly($barcode)    {        // Check if this item is a sub-assembly                $records = $this->SQL->GetArrayAll(array(            'table' => 'inventory_assemblies',            'keys'  => 'inventory_assemblies_id',            'where' => "barcode='{$barcode}' AND active=1"        ));        $this->EchoQuery();                $is_subassembly = ($records) ? 1 : 0;        return $is_subassembly;    }                public function FakeBuildRecord()    {        $sku_101 = array(            'barcode'           => 101,            'sku'               => 'D',            'quantity'          => 1,            'is_subassembly'    => 0,        );        $sku_102 = array(            'barcode'           => 102,            'sku'               => 'E',            'quantity'          => 2,            'is_subassembly'    => 0,        );        $sku_201 = array(            'barcode'           => 201,            'sku'               => 'B',            'quantity'          => 1,            'is_subassembly'    => 0,        );        $sku_202 = array(            'barcode'           => 202,            'sku'               => 'C',            'quantity'          => 3,            'is_subassembly'    => 1,            'assembly'          => array(),        );        $sku_301 = array(            'barcode'           => 301,            'sku'               => 'A',            'quantity'          => 1,            'is_subassembly'    => 1,            'assembly'          => array(),        );                                $return_arr = array();        $return_arr[0]                                  = $sku_301;        $return_arr[0]['assembly'][0]                   = $sku_201;        $return_arr[0]['assembly'][1]                   = $sku_202;        $return_arr[0]['assembly'][2]                   = $sku_102;        $return_arr[0]['assembly'][1]['assembly'][0]    = $sku_101;        $return_arr[0]['assembly'][1]['assembly'][1]    = $sku_102;                return $return_arr;    }        public function FakeBuildRecordCheck()    {        # FUNCTION :: Returns a qty array that matches FakeBuildRecord() - validates code        $arr = array (            301 => 10,            201 => 10,            202 => 30,            101 => 30,            102 => 80        );        return $arr;    }    }  // -------------- END CLASS --------------