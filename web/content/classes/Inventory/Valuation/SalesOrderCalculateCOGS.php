<?phpclass Inventory_Valuation_SalesOrderCalculateCOGS extends Inventory_InventoryBase{    public $Show_Query                          = false;    // (FALSE) TRUE = show database queries used in this class    public $Unset_Array_When_Used               = true;     // (true) TRUE = remove array element when totaly used up -- set to FALSE to verify functionality of counting algorithm    public $Show_Previous_Fulfilled             = true;     // (true) TRUE = show the inventory previously sent on this SO    public $Use_Fake_Data						= false;	// (false) TRUE = use fake data for arrays - DEV ONLY        // ===== INPUTS ====================    public $Record_ID                           = 0;        // database 'inventory_sales_orders_id' - can be passed in instead of     public $SO_Number                           = 0;    public $Inventory_Sales_Orders_ID 			= 0;    public $Method								= 'average';	// (average || fifo) method to use for calculating value	    // ===== OUTPUTS ====================    public $Barcode_Arr                         = array();    public $Inventory_In_Arr                    = array();    public $Inventory_Out_Arr                   = array();    public $Inventory_Current_Salesorder_Arr    = array();    public $COGS_Report                         = "";            // ===== GENERAL ====================                public function  __construct()    {        parent::__construct();                $this->Classname = get_class($this);        $this->ClassInfo = array(            'Created By'    => 'Richard Witherspoon',            'Created Date'  => '2012-11-14',            'Updated By'    => 'Richard Witherspoon',            'Updated Date'  => '2013-03-14',            'Filename'      => $this->Classname,            'Version'       => '1.2',            'Description'   => 'Calcualte the COGS for a given sales order',            'Update Log'    => array(                '2012-12-02_1.0'    => "Added in COGS_Report functionality to give detailed information. Updated the output to include more SO information.",                '2013-02-25_1.1'    => "Restructuring due to class changes",				'2013-03-14_1.2' 	=> "Refactored due to NOT using SO_Number as the main database field",            ),        );                $this->SetParameters(func_get_args());        $this->Inventory_Sales_Orders_ID	= $this->GetParameter(0);        $this->SO_Number    				= $this->GetParameter(1);            } // -------------- END __construct --------------            public function Pseudocode()    {        # FUNCTION :: Pseudocode for this class.                $output = "        [Description]:        Takes a given Sales Order ID and returns back a complete COGS report for all items found in the Sales Order.                        [Notes]        Note on COGS calculation:         |  If a sales order is modified or inventory added or deleted after a COGS report has been generated - it        |  will likely affect the COGS alrady reported. This is acurrate to the real world and how this code operates.        |  If you modify something - run a new COGS report and give new values to the accountants.                        Note on speed:        |  This function will get slower and slower the more products and invoices in the system. It has to calcualte        |  all historical                         Take in the sales order number (SON)        Get all the barcodes on this sales order - for each barcode determine the latest date        Get all the INs and OUTs prior to the latest sales order line date        Combine all the barcodes into a single array                LOOP             For each Barcode:            Subtract all the INs from the OUTs in ascending date order.            If the barcode is from the current sales order - trap its cost information for COGS        END LOOP                        [To Do List]:        Need to create more fake data cases that will trigger all types of errors:        Not enough inventory        Date range issues        Inventory item no longer existing        ";                $title      = "$this->Classname :: Pseudocode()";        $content    = $this->PseudocodeFormat($output);        $this->EchoInformation($title, $content, 'blue');            }        public function Execute($return=false)    {        # FUNCTION :: Main function called after instantiating this class        						        // ----- check that all needed information is present before COGS runs        $passed = $this->RunChecks();		if (!$passed) {			$error = "Did not pass checks to run COGS";            $this->AddError($this->Classname, __FUNCTION__, $error);            $this->EchoError($this->Classname, __FUNCTION__, $error);            exit();		}                        // ========== get all barcodes for this sales order ==========        $this->GetBarcodesSent($this->Inventory_Sales_Orders_ID);                        // ========== get all inventory counts and pricing information for each of the barcodes ==========        $this->GetInventoryCountForBarcodes();                		        // ----- create fake array of previous sales order        if ($this->Use_Fake_Data) {			$this->Inventory_In_Arr                   = $this->CreateFakeInArray();			$this->Inventory_Out_Arr                  = $this->CreateFakeOutArray();			$this->Inventory_Current_Salesorder_Arr   = $this->CreateFakeSalesOrderArray();        }		                        if (true) {            $this->EchoVar('Inventory_In_Arr', $this->Inventory_In_Arr);            $this->EchoVar('Inventory_Out_Arr', $this->Inventory_Out_Arr);            $this->EchoVar('Inventory_Current_Salesorder_Arr', $this->Inventory_Current_Salesorder_Arr);        }                        // ========== remove the quantities from old sales orders (not this current one) ==========        //$this->RemoveInventoryQuantityCalculateValue($this->Inventory_Out_Arr);                                                         // ========== PROCESS ARRAY FOR COGS ==========        		switch ($this->Method) {			case 'fifo':				$pricing_method 	= 'FIFO';				$cogs_arr 			= $this->CreateCOGSArray_FIFO($this->Inventory_Sales_Orders_ID);			break;						case 'average':				$pricing_method 	= 'Average Cost';				$cogs_arr 			= $this->CreateCOGSArray_Average($this->Inventory_Sales_Orders_ID);			break;		}                                // ========== CALCULATE THE COGS FOR THIS SALES ORDER ==========        $total_cogs = 0;        foreach ($cogs_arr AS $value) {            $total_cogs += $value;        }        $total_cogs = money_format('%n', $total_cogs);                        $output = "";        $output .= "<div style='width:300px;'></div>";        $output .= $this->OutputCOGS($total_cogs);        $output .= $this->DumpErrors(true);        $output .= $this->DumpNotices(true);        $output .= "<h2>DETAILED COGS REPORT</h2>";        $output .= "<div>Selected Pricing Method: {$pricing_method}</div>";		$output .= $this->COGS_Report;                        if ($return) {            return $output;        } else {            echo $output;        }                return $total_cogs;    }            	public function RunChecks()	{		# FUNCTION :: Run a series of checks to see if Class has information needed for processing COGS				$passed = true;				// ========== check if we have a sales order number - and get it if not ==========		if (!$this->SO_Number) {			// get SO_Number from Inventory_Sales_Orders_ID			$record = $this->SQL->GetRecord(array(				'table' => 'inventory_sales_orders',				'keys'  => 'so_number, updated',				'where' => "`inventory_sales_orders_id`='{$this->Inventory_Sales_Orders_ID}'",			));			$this->EchoQuery();						if ($record) {				$this->SO_Number = $record['so_number'];			}        }		        if (!$this->SO_Number) {            $passed = false;            $error = "No SO_Number passed in or found from Record_ID";            $this->AddError($this->Classname, __FUNCTION__, $error);            return false;	// return now or other errors will kill function        }                				// ========== check if we have a sales order number - and get it if not ==========        if (!$this->Inventory_Sales_Orders_ID) {			$passed = false;			$error = "No Inventory_Sales_Orders_ID passed in";			$this->AddError($this->Classname, __FUNCTION__, $error);			return false;	// return now or other errors will kill function		}						// ========== check if sales order still exists in system		$so_exists = $this->StatusSalesOrderExist(0, $this->Inventory_Sales_Orders_ID);        if (!$so_exists) {            $error = "Sales Order not found in database";            $this->AddError($this->Classname, __FUNCTION__, $error);            return false;	// return now or other errors will kill function        }		        // ========== get status of sales order ==========        $status = $this->StatusSalesOrder(0, $this->Inventory_Sales_Orders_ID);        if ($status != 'closed') {            $notice = "Sales order is not closed - some items are unfulfilled";            $this->AddNotice($this->Classname, __FUNCTION__, $notice);        }				return $passed;	}	    public function OutputCOGS($VALUE)    {        $date = date("Y-m-d H:i:s");        $info = "            <b>Sales Order Number:</b> {$this->SO_Number}<br />            <b>COGS:</b> {$VALUE}<br />            <b>Report Generated Timestamp:</b> {$date}<br />            ";        $title = "{$this->Classname} :: OutputCOGS()";        $output = $this->EchoInformation($title, $info, 'black', false);                return $output;    }                    public function GetBarcodesSent($INVENTORY_SALES_ORDERS_ID=0)    {        # FUNCTION :: get all barcodes for this sales order and the latest date for that barcode        		if (!$INVENTORY_SALES_ORDERS_ID) {			$error = "No INVENTORY_SALES_ORDERS_ID passed into function";            $this->AddError($this->Classname, __FUNCTION__, $error);            $this->EchoError($this->Classname, __FUNCTION__, $error);            exit();		}		        $records = $this->SQL->GetArrayAll(array(            'table' => 'inventory_sales_order_sent',            'keys'  => 'barcode, sum(`quantity`) AS quantity, date, max(`date`) AS MAX_DATE',            'where' => "`inventory_sales_orders_id`='{$INVENTORY_SALES_ORDERS_ID}' AND `active`=1 GROUP BY `barcode`",        ));        $this->EchoQuery();                if ($records) {                        $this->Inventory_Current_Salesorder_Arr = array();            foreach ($records as $record) {                $this->Inventory_Current_Salesorder_Arr[$record['barcode']][] = array(                    'date'      => $record['date'],                    'date_max'  => $record['MAX_DATE'],                    'qty_out'   => $record['quantity'],                );            }                    } else {            $passed = false;            $error = "No lines found for this sales order";            $this->AddError($this->Classname, __FUNCTION__, $error);            return false;        } // end records (sales order lines) check    }        public function GetInventoryCountForBarcodes($DATE='')    {        // ========== get all inventory counts and pricing information for each of the barcodes ==========        // ----- order by updated date for processing        // ----- limit to inventory prior to the sales order date        // purchased inventory always has a purchase order with the price in it        // adjusting inventory down has an adjustment record - but price doesn't matter - its just gone (matters for year-end slippage)        // adjusting inventory up has an adjustment record - which will use the last pricing it can determine - has price in it        // get the part_cost as a default if it has not been purchased in the history                        $this->Inventory_In_Arr     = array();      // instantiate array that will hold all inbound inventory        $this->Inventory_Out_Arr    = array();      // instantiate array that will hold all outbound inventory                foreach ($this->Inventory_Current_Salesorder_Arr AS $barcode => $array) {                        // ----- initialize blank values into array - keeps errors from happening later            $this->Inventory_In_Arr[$barcode][] = array(                'date'          => '1881-11-16',                'qty_in'        => 0,                'cost'          => 0,                'qty_used'      => 0,            );            $this->Inventory_Out_Arr[$barcode][] = array(                'date'          => '1881-11-16',                'qty_out'       => 0,            );                        $unset_inventory_in     = true;     // on first stored record - delete this fake record            $unset_inventory_out    = true;     // on first stored record - delete this fake record                                    // ----- get the max date for this barcode - so we don't pull inventory items passed this invoice            // ----- NOTE :: Currently disabled in actual query            $date_so_line = $array[0]['date_max'];                                    // ----- get the INs and OUTs of barcode inventory            /*			$Obj_InventoryMovements             = new Inventory_BarcodeSummaryReport();            $Obj_InventoryMovements->Barcode    = $barcode;            $Obj_InventoryMovements->Date       = $DATE;            $records                            = $Obj_InventoryMovements->GetInventoryMovements();            */						$records = $this->GetInventoryMovements($barcode, $DATE);			// call to InventoryBase for this						                        // ----- DEBUG VARIABLES -----            if (false) {                echo "<div style='border:5px solid green;'>";                $this->EchoVar('BARCODE', $barcode);                $this->EchoVar('RECORDS', $records);                echo "</div>";            }                    foreach ($records as $record) {                								// ----- PROCESS THE RECORD - DETERMINE ITS TYPE - How was this inventory brought into the system				$type       = '';				$type       = ($record['ref_purchase_orders_received_id'] != 0)   ? 'purchaseorder'   : $type;				$type       = ($record['ref_adjustment_id'] != 0)                 ? 'adjustment'      : $type;				$type       = ($record['ref_sales_order_sent_id'] != 0)           ? 'salesorder'      : $type;				$type       = ($record['ref_assembly_build_id'] != 0)             ? 'assembly'        : $type;				                				switch($type) {    										case 'purchaseorder':						$method_text 		= "purchase order";								// method the inventory change was made with						$method_id          = $record['ref_purchase_orders_received_id'];	// method ID the inventory change was made with						$date				= $record['IN_DATE'];							// date the inventory change was made on                                                $price_total        = $record['IN_PRICE_TOTAL'];                        $shipping_total     = $record['IN_PRICE_SHIPPING_TOTAL'];					break;										case 'adjustment':						$method_text 		= "inventory adjustment";						// method the inventory change was made with						$method_id          = $record['ref_adjustment_id'];					// method ID the inventory change was made with						$date				= $record['ADJ_DATE'];                          // date the inventory change was made on						                        $price_total        = $record['ADJ_PRICE_TOTAL'];                        $shipping_total     = $record['ADJ_PRICE_SHIPPING_TOTAL'];					break;										case 'salesorder':						$method_text 		= "sales order";								// method the inventory change was made with						$method_id          = $record['ref_sales_order_sent_id'];			// method ID the inventory change was made with						$date				= $record['OUT_DATE'];							// date the inventory change was made on						                        $price_total        = 0;                        $shipping_total     = 0;					break;										case 'assembly':						$method_text 		= "assembly build";								// method the inventory change was made with						$method_id          = $record['ref_assembly_build_id'];				// method ID the inventory change was made with						$date				= $record['ASSY_DATE'];							// date the inventory change was made on						                        $price_total        = $record['ASSY_PRICE_TOTAL'];  // (BAD - actually have to calculate value)                        $shipping_total     = 0;					break;										default:						$error = "Unable to determine inventory movement method";						$this->AddError($this->Classname, __FUNCTION__, $error);						$this->EchoError($this->Classname, __FUNCTION__, $error);						exit();					break;				}												                // ----- determine the actual INBOUND cost for this item                $quantity               = $record['qty_in'] + $record['qty_out'];                   // can't be both inbound and outbound inventory - so this gives correct quantity                 $cost_each_default      = $record['DEFAULT_PRICE_EACH'];                            // default cost for barcode                                $price_total            = ($price_total > 0) ? $price_total : $cost_each_default;   // set to default_cost if no stored value                $shipping_total         = ($shipping_total > 0) ? $shipping_total : 0;              // make sure there's a value for shipping (even if $0)                                $cost_total             = $price_total + $shipping_total;                           // calculate total price                $cost_each              = ($cost_total / $quantity);                                // calcualte each price                                                                if ($record['qty_in'] > 0) {                                        // remove the blank record being stored                    if ($unset_inventory_in) {                        unset($this->Inventory_In_Arr[$record['barcode']][0]);                        $unset_inventory_in = false;                    }                                        // store the actual record                    $this->Inventory_In_Arr[$record['barcode']][] = array(                        'date'          => $date,                        'qty_in'        => $record['qty_in'],                        'cost_each'     => $cost_each,                        'cost_total'    => $cost_total,                        'qty_used'      => 0,                        'method'        => $method_text,                        'method_id'     => $method_id,                        'description'   => "{$record['retailer_code']}<br />{$record['description']}",                    );                }                                if ($record['qty_out'] > 0) {                                        // ----- remove the blank record being stored                    if ($unset_inventory_out) {                        unset($this->Inventory_Out_Arr[$record['barcode']][0]);                        $unset_inventory_out = false;                    }                                        // ----- store the actual record                    $this->Inventory_Out_Arr[$record['barcode']][] = array(                        'date'                              => $date,                        'qty_out'                           => $record['qty_out'],                        'out_inventory_sales_orders_id'     => $record['out_inventory_sales_orders_id'],                        'method'                            => $method_text,                        'method_id'                         => $method_id,                        'description'                       => "{$record['retailer_code']}<br />{$record['description']}",                    );                }            }        } // end foreach $this->Inventory_Current_Salesorder_Arr    }        public function CreateCOGSArray_FIFO($INVENTORY_SALES_ORDERS_ID=0)    {        # FUNCTION :: Loops through the quantity arrays and removed inventory being used        #             Also calcualtes the value of that inventory being removed and returns it - this calculation        #             can be used to determine value of sales order or ignored if just removing inventory counts.		#        # INVENTORY_SALES_ORDERS_ID = Sales order ID that should be calculated and COGS returned                if (!$INVENTORY_SALES_ORDERS_ID) {			$error = "No INVENTORY_SALES_ORDERS_ID passed into function";            $this->AddError($this->Classname, __FUNCTION__, $error);            $this->EchoError($this->Classname, __FUNCTION__, $error);            exit();		}				$report_lines = '';     // initialize variable        $return_arr = array();  // will hold the return COGS values                // ----- DEBUG VARIABLES -----        if (false) {            // ----- show the base array information that will be worked on -----            echo "<div style='border:1px solid red; padding:10px;'>";            $this->EchoVar('INVENTORY_SALES_ORDERS_ID', $INVENTORY_SALES_ORDERS_ID);			$this->EchoVar('SO_Number', $this->SO_Number);            $this->EchoVar('Inventory_Current_Salesorder_Arr', $this->Inventory_Current_Salesorder_Arr);            $this->EchoVar('Inventory_Out_Arr', $this->Inventory_Out_Arr);            $this->EchoVar('Inventory_In_Arr', $this->Inventory_In_Arr);            echo "</div>";        }                                                        // ----- loop through each barcode used in this salesorder -----        foreach ($this->Inventory_Current_Salesorder_Arr AS $barcode => $arr) {                        //$this->EchoVar('barcode', $barcode);                        // ----- loop through each record that has this barcode going out of inventory -----            if (isset($this->Inventory_Out_Arr[$barcode])) {                            // ----- process each record of inventory going out -----                foreach ($this->Inventory_Out_Arr[$barcode] AS $idx => $record_out) {                                            $total_left_to_remove   		= $record_out['qty_out'];        // get the total we need to take out of inventory for a given barcode                    $removal_date           		= $record_out['date'];           // get date of inventory removal (can't remove inventory after this date)                    $out_inventory_sales_orders_id	= isset($record_out['inventory_sales_orders_id']) ? $record_out['inventory_sales_orders_id'] : 0;                    					###$this->EchoVar('A:: out_inventory_sales_orders_id', $out_inventory_sales_orders_id);                                        if (false) {                        echo "<br /><br />";                        $this->EchoVar('barcode', $barcode);                        $this->EchoVar('total_left_to_remove', $total_left_to_remove);                        $this->EchoVar('out_inventory_sales_orders_id', $out_inventory_sales_orders_id);                        //$this->EchoVar('Inventory_In_Arr', $this->Inventory_In_Arr);                    }                                        // ----- loop through the IN array and remove the out quantity                    foreach ($this->Inventory_In_Arr[$barcode] AS $id => $record) {                                                                        ###$this->EchoVar('rec', $this->Inventory_In_Arr[$barcode]);                                                ###$this->EchoVar('@@ barcode', $barcode);                        ///if ($barcode == 10110) {                        if ($total_left_to_remove > 0) {                                                        ###$this->EchoVar('total_left_to_remove', $total_left_to_remove);                                                        // ----- determine if inventory was in system prior to this out date                            // ----- if not its a critical failure that must be fixed first                            //$record['date'] = date("Y-m-d");                            if ($record['date'] > $removal_date) {                                $passed     = false;                                $error      = "Inventory does not exist in system as of the date trying to remove. As of <b>({$removal_date})</b> there needs to be <b>({$total_left_to_remove})</b> more in inventory for barcode <b>({$barcode})</b>.";                                $this->AddError($this->Classname, __FUNCTION__, $error);                                                                if ($out_inventory_sales_orders_id == $SO_NUMBER) {                                    $report_lines .= "<tr><td>{$barcode}</td><td>{$record['description']}</td><td colspan='6'>{$error}</td></tr>";                                }                                                                $this->COGS_Report = $this->MakeCOGSReport($report_lines);                                return false;                            }                                                        // ----- determine how many are still available in this record                            $cur_available_in_record = $record['qty_in'] - $record['qty_used'];                                                        if (false) {                                echo "<br /><br />";                                $this->EchoVar('qty_in', $record['qty_in']);                                $this->EchoVar('qty_used', $record['qty_used']);                                $this->EchoVar('cur_available_in_record', $cur_available_in_record);                            }                                                                                        ###$this->EchoVar('cur_available_in_record', $cur_available_in_record);                            if ($cur_available_in_record >= $total_left_to_remove) {                                                                                                // ----- have enough in this record to account for all OUT                                $new_qty_used               = $record['qty_used'] + $total_left_to_remove;          // mark record as partialy or totally used up                                $line_quantity              = $total_left_to_remove;                                $cogs                       = $line_quantity * $record['cost_each'];                // calculate COGS for this line                                $total_left_to_remove       = 0;                                                    // adjust that all of this barcode has been removed                                $this->Inventory_In_Arr[$barcode][$id]['qty_used'] = $new_qty_used;                 // store the values                            /*if ($out_inventory_sales_orders_id == $SO_NUMBER) {    echo "<br />AAAAAAAAAA";}*/                                                        } else {                                // ----- DO NOT have enough in this record to account for all OUT                                $new_qty_used               = $record['qty_in'];                                    // mark record as totally used up                                $line_quantity              = $cur_available_in_record;                                $cogs                       = $line_quantity * $record['cost_each'];                // calculate COGS for this line                                $total_left_to_remove       = $total_left_to_remove - $cur_available_in_record;     // adjust how much left to remove                                                                if ($this->Unset_Array_When_Used) {                                    // ----- blow out the array element if we've used up all the qty - speeds up future array checks                                    unset($this->Inventory_In_Arr[$barcode][$id]);                                }                                /*if ($out_inventory_sales_orders_id == $SO_NUMBER) {    echo "<br />BBBBBBBBBBBBB";}*/                                                            }                                                        // ----- calculate the COGS value for this barcode - if its the sales order we want                            if (false) {                                $this->EchoVar('out_inventory_sales_orders_id', $out_inventory_sales_orders_id);                                $this->EchoVar('INVENTORY_SALES_ORDERS_ID', $INVENTORY_SALES_ORDERS_ID);                                $this->EchoVar('cogs', $cogs);                                //$this->EchoVar('ra[bc]', $return_arr[$barcode]);                            }                                                                                    if ($line_quantity > 0) {                                if ($out_inventory_sales_orders_id == $INVENTORY_SALES_ORDERS_ID) {                                                                                                            ###$this->EchoVar('##### barcode', $barcode);                                                                        // ----- store the COGS value for the return array                                    $return_arr[$barcode] = isset($return_arr[$barcode]) ? ($return_arr[$barcode] + $cogs) : $cogs;                                                                                                                                                //$this->EchoVar('BB:: record in', $record);                                                                        // ----- add a line to the COGS report table                                    $cogs_each      = money_format('%n', $record['cost_each']);                                    $cogs_total     = money_format('%n', $cogs);                                    $date_parts     = explode(" ", $record['date']);                                    $date           = $date_parts[0];                                                                        $report_lines .= "                                        <tr>                                            <td>{$barcode}</td>                                            <td>{$record['description']}</td>                                            <td>{$line_quantity}</td>                                            <td>{$cogs_each}</td>                                            <td>{$cogs_total}</td>                                            <td>{$date}</td>                                            <td>{$record['method']}</td>                                            <td>{$record['method_id']}</td>                                        </tr>                                        ";                                } // end verifying this COGS value is associate with Sales Order                            } // end checking line quantity > 0                                                                                } // end if loop                        ///} // delete this *****                    } // end foreach loop                                        //$this->EchoVar('total_left_to_remove', $total_left_to_remove);                                                            // ----- check if enough inventory still in the inventory pool                    // ----- we have removed all inventory from the IN array - but there's still more                    if ($total_left_to_remove > 0) {                        $passed = false;                        $error = "Not enough inventory available to remove. Barcode: {$barcode}. Left to Remove: {$total_left_to_remove}.";                        $this->AddError($this->Classname, __FUNCTION__, $error);                        $this->COGS_Report = $this->MakeCOGSReport($report_lines);                    }                                                        } // end foreach            } else {                $passed = false;                $error = "BARCODE NOT FOUND IN INVENTORY - Barcode: <b>{$barcode}</b>";                $this->AddError($this->Classname, __FUNCTION__, $error);                            } // end if        } // end foreach                        if (false) {            $this->EchoVar('return_arr', $return_arr);        }                        // ----- make the COGS report        $this->COGS_Report = $this->MakeCOGSReport($report_lines);                                return $return_arr;    }    public function CreateCOGSArray_Average($INVENTORY_SALES_ORDERS_ID=0)    {        # FUNCTION :: Determine value of COGS through 'average' method                if (!$INVENTORY_SALES_ORDERS_ID) {			$error = "No INVENTORY_SALES_ORDERS_ID passed into function";            $this->AddError($this->Classname, __FUNCTION__, $error);            $this->EchoError($this->Classname, __FUNCTION__, $error);            exit();		}    }            public function MakeCOGSReport($LINES)    {       $output = "            <table border='1' id='jsonTable'>                <tr>                    <th>Barcode</th>                    <th>Description</th>                    <th>QTY From Inventory</th>                    <th>COGS / Each</th>                    <th>COGS / Total</th>                    <th>Date Of Inventory INTO Inventory</th>                    <th>Inbound Inventory Type</th>                    <th>Inbound Inventory Ref #</th>                </tr>                {$LINES}                <tr>                    <td colspan='8'>                        <ul>                        <li>COGS values shown are rounded resulting in difference between each and total COGS. Final COGS value for sales order is rounded after summing all non-rounded COGS values.</li>                        <li>There may be multiple entries for a given barcode. This indicates inventory items were withdrawn from multiple inventory inputs.</li>                        </ul>                            </td>                </tr>            </table>";                        return $output;    }                private function CreateFakeInArray()    {        $arr = Array(                '20008' => Array(                        '0' => Array(                                'date' => '2012-10-01 00:00:00',                                'qty_in' => '50',                                'cost' => '0.50',                                'qty_used' => '0',                            ),                    ),                '20081' => Array(                        '0' => Array(                                'date' => '2012-10-01 00:00:00',                                'qty_in' => '5',                                'cost' => '0.25',                                'qty_used' => '0',                            ),                        '1' => Array(                                'date' => '2012-10-02 00:00:00',                                'qty_in' => '5',                                'cost' => '1.25',                                'qty_used' => '0',                            ),                        '2' => Array(                                'date' => '2012-10-03 00:00:00',                                'qty_in' => '50',                                'cost' => '1.50',                                'qty_used' => '0',                            ),                    ),            );                    return $arr;    }    private function CreateFakeOutArray()    {        $arr = Array(                '20008' => Array(                        '0' => Array(                                'date' => '2012-11-01 00:00:00',                                'qty_out' => '5',                            ),                    ),                '20081' => Array(                        '0' => Array(                                'date' => '2012-11-01 00:00:00',                                'qty_out' => '2',                            ),                        '1' => Array(                                'date' => '2012-11-02 00:00:00',                                'qty_out' => '7',                            ),                        '2' => Array(                                'date' => '2012-11-03 00:00:00',                                'qty_out' => '1',                            ),                        '3' => Array(                                'date' => '2012-11-04 00:00:00',                                'qty_out' => '1',                            ),                        '4' => Array(                                'date' => '2012-11-05 00:00:00',                                'qty_out' => '1',                            ),                    ),            );                /*        # condense the array        $arr2 = array();        foreach ($arr AS $barcode => $array) {            foreach ($array AS $id => $record) {                $existing_qty   = isset($arr2[$barcode]['qty_out']) ? $arr2[$barcode]['qty_out'] : 0;                $new_qty        = $existing_qty + $record['qty_out'];                                $arr2[$barcode] = array(                    'qty_out'  => $new_qty,                );            };        };        */                        return $arr;    }        private function CreateFakeSalesOrderArray()    {        $arr = Array(                '20008' => Array(                        '0'=> Array(                                'date' => '2012-11-10 00:00:00',                                'qty_out' => '16',                            ),                    ),                '20081' => Array(                        '0' => Array(                                'date' => '2012-11-10 00:00:00',                                'qty_out' => '7',                            ),                        '1' => Array(                                'date' => '2012-11-10 00:00:00',                                'qty_out' => '2',                            ),                    ),            );                    return $arr;    }        }  // -------------- END CLASS --------------