<?phpclass Inventory_Valuation_SalesOrderCalculateCOGS extends Inventory_InventoryBase{    public $Show_Query                          = false;    // (FALSE) TRUE = show database queries used in this class    public $Unset_Array_When_Used               = true;     // (true) TRUE = remove array element when totaly used up -- set to FALSE to verify functionality of counting algorithm    public $Show_Previous_Fulfilled             = true;     // (true) TRUE = show the inventory previously sent on this SO    public $Use_Fake_Data						= false;	// (false) TRUE = use fake data for arrays - DEV ONLY        // ===== INPUTS ====================    public $Record_ID                           = 0;        // database 'inventory_sales_orders_id' - can be passed in instead of     public $SO_Number                           = 0;    public $Inventory_Sales_Orders_ID 			= 0;    public $Method								= 'average';	// (average || fifo) method to use for calculating value	public $Show_Value_Sent_Inventory           = true;         // (true) TRUE = calculate COGS for the sent inventory    public $Show_Value_Unsent_Inventory         = true;         // (true) TRUE = calculate COGS for the unsent inventory            // ===== OUTPUTS ====================    public $Barcode_Arr                         = array();    public $Inventory_In_Arr                    = array();      // will hold inventory movements that come INTO system    public $Inventory_Out_Arr                   = array();      // will hold inventory movements that go OUT of system    public $Inventory_Value_Average_Arr         = array();      // will hold value of inventory - when using 'average' COGS method    public $Inventory_Salesorder_All_Arr        = array();      // will hold ALL barcodes tied to this salesorder    public $Inventory_Salesorder_Sent_Arr       = array();      // will hold SENT barcodes tied to this salesorder    public $Inventory_Salesorder_Unsent_Arr     = array();      // will hold UNSENT barcodes tied to this salesorder    public $COGS_Report                         = '';                // ===== GENERAL ====================    public $Show_Method_Details                 = false;        // GET variable which will show details    public $Show_Assembly_Details               = false;        // GET variable which will show details    public $Pricing_Method_Used                 = '';           // Will hold the pricing method used            public function  __construct()    {        parent::__construct();                $this->Classname = get_class($this);        $this->ClassInfo = array(            'Created By'    => 'Richard Witherspoon',            'Created Date'  => '2012-11-14',            'Updated By'    => 'Richard Witherspoon',            'Updated Date'  => '2013-03-14',            'Filename'      => $this->Classname,            'Version'       => '1.2',            'Description'   => 'Calcualte the COGS for a given sales order',            'Update Log'    => array(                '2012-12-02_1.0'    => "Added in COGS_Report functionality to give detailed information. Updated the output to include more SO information.",                '2013-02-25_1.1'    => "Restructuring due to class changes",				'2013-03-14_1.2' 	=> "Refactored due to NOT using SO_Number as the main database field",            ),        );                $this->SetParameters(func_get_args());        $this->Inventory_Sales_Orders_ID	= $this->GetParameter(0);        $this->SO_Number    				= $this->GetParameter(1);                // ----- initialize GET variables        $this->Show_Method_Details      = (Get('methoddetails') == 'true') ? true : false;        $this->Show_Assembly_Details    = (Get('assemblydetails') == 'true') ? true : false;            } // -------------- END __construct --------------            public function Pseudocode()    {        # FUNCTION :: Pseudocode for this class.                $output = "        [Description]:        Takes a given Sales Order ID and returns back a complete COGS report for all items found in the Sales Order.                        [Notes]        Note on COGS calculation:         |  If a sales order is modified or inventory added or deleted after a COGS report has been generated - it        |  will likely affect the COGS alrady reported. This is acurrate to the real world and how this code operates.        |  If you modify something - run a new COGS report and give new values to the accountants.                        Note on speed:        |  This function will get slower and slower the more products and invoices in the system. It has to calcualte        |  all historical                         Take in the sales order number (SON)        Get all the barcodes on this sales order - for each barcode determine the latest date        Get all the INs and OUTs prior to the latest sales order line date        Combine all the barcodes into a single array                LOOP             For each Barcode:            Subtract all the INs from the OUTs in ascending date order.            If the barcode is from the current sales order - trap its cost information for COGS        END LOOP                        [To Do List]:        Need to create more fake data cases that will trigger all types of errors:        Not enough inventory        Date range issues        Inventory item no longer existing        ";                $title      = "$this->Classname :: Pseudocode()";        $content    = $this->PseudocodeFormat($output);        $this->EchoInformation($title, $content, 'blue');            }        public function Execute($return=false)    {        # FUNCTION :: Main function called after instantiating this class                $output = "";                                           // initialize variable        $output .= "<div style='width:300px;'></div>";          // set report width                        // ----- check that all needed information is present before COGS runs        $passed = $this->RunChecks();		if (!$passed) {			$error = "Did not pass checks to run COGS";            $this->AddError($this->Classname, __FUNCTION__, $error);            $this->EchoError($this->Classname, __FUNCTION__, $error);            exit();		}                        // ========== remove the quantities from old sales orders (not this current one) ==========        //$this->RemoveInventoryQuantityCalculateValue($this->Inventory_Out_Arr);                                                         // ========== PROCESS ARRAY FOR COGS ==========        switch ($this->Method) {			case 'fifo':				$this->GetBarcodesSent($this->Inventory_Sales_Orders_ID);                                           // get all barcodes for this sales order                $this->GetInventoryValues_FIFO();                                                                   // calculate value of inventory                				$cogs_arr 			        = $this->CreateCOGSArray_FIFO($this->Inventory_Sales_Orders_ID);        // create cogs_array                $total_cogs                 = $this->CalculateTotalCOGS($cogs_arr);                                 // get total COGS for this order                $this->Pricing_Method_Used 	= 'FIFO';                                                               // store method text for output report			break;						case 'average':				$this->Pricing_Method_Used 	= 'Average Cost';                                                   // store method text for output report                                // ----- PROCESS THE SENT INVENTORY COGS                if ($this->Show_Value_Sent_Inventory) {                    $result = $this->GetBarcodesSent($this->Inventory_Sales_Orders_ID);                                 // get all barcodes for this sales order                                        if ($result) {                        $barcode_array              = $this->Inventory_Salesorder_Sent_Arr;                             // set barcode array to get value for                        $value_array                = $this->GetInventoryValues_Average($barcode_array);                // calculate value of inventory                        $cogs_arr 			        = $this->CreateCOGSArray_Average($barcode_array, $value_array);     // create cogs_array                        $total_cogs                 = $this->CalculateTotalCOGS($cogs_arr);                             // get total COGS for this order                                                // ----- output the report                        $output .= $this->OutputCOGSHeader($total_cogs, 'SENT INVENTORY');                        $output .= $this->COGS_Report;                        $output .= "</br></br>";                                            } else {                        $output .= $this->OutputCOGSHeader(0, 'SENT INVENTORY');                        $output .= "<div style='border:2px solid red; color:red;'>NO SENT INVENTORY</div>";                        $output .= "</br></br>";                    }                }                                                // ----- PROCESS THE UNSENT INVENTORY COGS                if ($this->Show_Value_Unsent_Inventory) {                    $result = $this->GetBarcodesAll($this->Inventory_Sales_Orders_ID);                                  // get ALL the brcodes for this salesorder                                        if ($result) {                                                $result_sent = $this->GetBarcodesSent($this->Inventory_Sales_Orders_ID);                        // get all barcodes for this sales order                        if ($result_sent) {                            $this->RemoveSentBarcodesFromAllBarcodes();                                                 // determine the UNSENT barcodes for this salesorder                        } else {                            $this->Inventory_Salesorder_Unsent_Arr = $this->Inventory_Salesorder_All_Arr;                        }                                                $barcode_array              = $this->Inventory_Salesorder_Unsent_Arr;                           // set barcode array to get value for                        $value_array                = $this->GetInventoryValues_Average($barcode_array);                // calculate value of inventory                        $cogs_arr 			        = $this->CreateCOGSArray_Average($barcode_array, $value_array);     // create cogs_array                        $total_cogs                 = $this->CalculateTotalCOGS($cogs_arr);                             // get total COGS for this order                                                // ----- output the report                        $output .= $this->OutputCOGSHeader($total_cogs, 'UNSENT INVENTORY');                        $output .= $this->COGS_Report;                        $output .= "</br></br>";                    } else {                        $output .= $this->OutputCOGSHeader(0, 'UNSENT INVENTORY');                        $output .= "<div style='border:2px solid red; color:red;'>NO UNSENT INVENTORY</div>";                        $output .= "</br></br>";                    }                }                			break;		}                                // ----- output the error and notices        $output .= $this->DumpErrors(true);        $output .= $this->DumpNotices(true);                                if ($return) {            return $output;        } else {            echo $output;            //return $total_cogs;        }    }            	public function RunChecks()	{		# FUNCTION :: Run a series of checks to see if Class has information needed for processing COGS				$passed = true;				// ========== check if we have a sales order number - and get it if not ==========		if (!$this->SO_Number) {			// get SO_Number from Inventory_Sales_Orders_ID			$record = $this->SQL->GetRecord(array(				'table' => 'inventory_sales_orders',				'keys'  => 'so_number, updated',				'where' => "`inventory_sales_orders_id`='{$this->Inventory_Sales_Orders_ID}'",			));			$this->EchoQuery();						if ($record) {				$this->SO_Number = $record['so_number'];			}        }		        if (!$this->SO_Number) {            $passed = false;            $error = "No SO_Number passed in or found from Record_ID";            $this->AddError($this->Classname, __FUNCTION__, $error);            return false;	// return now or other errors will kill function        }                				// ========== check if we have a sales order number - and get it if not ==========        if (!$this->Inventory_Sales_Orders_ID) {			$passed = false;			$error = "No Inventory_Sales_Orders_ID passed in";			$this->AddError($this->Classname, __FUNCTION__, $error);			return false;	// return now or other errors will kill function		}						// ========== check if sales order still exists in system		$so_exists = $this->StatusSalesOrderExist(0, $this->Inventory_Sales_Orders_ID);        if (!$so_exists) {            $error = "Sales Order not found in database";            $this->AddError($this->Classname, __FUNCTION__, $error);            return false;	// return now or other errors will kill function        }		        // ========== get status of sales order ==========        $status = $this->StatusSalesOrder(0, $this->Inventory_Sales_Orders_ID);        if ($status != 'closed') {            $notice = "Sales order is not closed - some items are unfulfilled";            $this->AddNotice($this->Classname, __FUNCTION__, $notice);        }				return $passed;	}	                public function RemoveSentBarcodesFromAllBarcodes()    {        # FUNCTION :: Remove all the sent items from the complete items list                if (!$this->Inventory_Salesorder_All_Arr) {			$error = "No this->Inventory_Salesorder_All_Arr";            $this->AddError($this->Classname, __FUNCTION__, $error);            $this->EchoError($this->Classname, __FUNCTION__, $error);            exit();		}                if (!$this->Inventory_Salesorder_Sent_Arr) {			$error = "No this->Inventory_Salesorder_Sent_Arr";            $this->AddError($this->Classname, __FUNCTION__, $error);            $this->EchoError($this->Classname, __FUNCTION__, $error);            exit();		}                $temp_sent_arr = $this->Inventory_Salesorder_All_Arr;                // ----- loop through all barocodes        foreach ($temp_sent_arr as $barcode => $record) {                        // ----- calculate the unset quantity            $qty_salesorder     = $record['qty_out'];            $qty_sent           = (isset($this->Inventory_Salesorder_Sent_Arr[$barcode])) ? $this->Inventory_Salesorder_Sent_Arr[$barcode]['qty_out'] : 0;            $qty_unset          = $qty_salesorder - $qty_sent;                                    // ----- handle what should be done with the record            if ($qty_unset == 0) {                // ----- remove the record if it has been sent                unset($temp_sent_arr[$barcode]);            } elseif ($qty_unset > 0) {                // ----- update record to reflect quantity not sent                $temp_sent_arr[$barcode] = $qty_unset;            } elseif ($qty_unset < 0) {                $error = "More inventory being sent that in the original salesorder";                $this->AddError($this->Classname, __FUNCTION__, $error);                $this->EchoError($this->Classname, __FUNCTION__, $error);                exit();            }                    }                // ----- store the unsent inventory        $this->Inventory_Salesorder_Unsent_Arr = $temp_sent_arr;    }                public function GetBarcodesAll($INVENTORY_SALES_ORDERS_ID=0)    {        # FUNCTION :: get all barcodes for this sales order that have NOT been sent        		if (!$INVENTORY_SALES_ORDERS_ID) {			$error = "No INVENTORY_SALES_ORDERS_ID passed into function";            $this->AddError($this->Classname, __FUNCTION__, $error);            $this->EchoError($this->Classname, __FUNCTION__, $error);            exit();		}		        // ----- get all the sales order lines from database        $records = $this->SQL->GetArrayAll(array(            'table' => 'inventory_sales_order_lines',            'keys'  => 'barcode, sum(`quantity`) AS quantity',            'where' => "`inventory_sales_orders_id`='{$INVENTORY_SALES_ORDERS_ID}' AND `active`=1 GROUP BY `barcode`",        ));        $this->EchoQuery();                if ($records) {                        $this->Inventory_Salesorder_All_Arr = array();            foreach ($records as $record) {                $this->Inventory_Salesorder_All_Arr[$record['barcode']][] = array(                    'date'      => '', //$record['date'],                    'date_max'  => '', //$record['MAX_DATE'],                    'qty_out'   => $record['quantity'],                );            }            $return = true;                    } else {            $error = "No lines found for this sales order";            $this->AddError($this->Classname, __FUNCTION__, $error);            $return = false;        } // end records (sales order lines) check                return $return;    }        public function GetBarcodesSent($INVENTORY_SALES_ORDERS_ID=0)    {        # FUNCTION :: get all barcodes for this sales order and the latest date for that barcode        		if (!$INVENTORY_SALES_ORDERS_ID) {			$error = "No INVENTORY_SALES_ORDERS_ID passed into function";            $this->AddError($this->Classname, __FUNCTION__, $error);            $this->EchoError($this->Classname, __FUNCTION__, $error);            exit();		}		        $records = $this->SQL->GetArrayAll(array(            'table' => 'inventory_sales_order_sent',            'keys'  => 'barcode, sum(`quantity`) AS quantity, date, max(`date`) AS MAX_DATE',            'where' => "`inventory_sales_orders_id`='{$INVENTORY_SALES_ORDERS_ID}' AND `active`=1 GROUP BY `barcode`",        ));        $this->EchoQuery();                if ($records) {                        $this->Inventory_Salesorder_Sent_Arr = array();            foreach ($records as $record) {                $this->Inventory_Salesorder_Sent_Arr[$record['barcode']][] = array(                    'date'      => $record['date'],                    'date_max'  => $record['MAX_DATE'],                    'qty_out'   => $record['quantity'],                );            }            $return = true;        } else {            $error = "No lines found for this sales order";            $this->AddError($this->Classname, __FUNCTION__, $error);            $this->EchoError($this->Classname, __FUNCTION__, $error);            $return = false;        } // end records (sales order lines) check                return $return;    }        public function GetInventoryValues_FIFO($DATE='')    {        // ========== get all inventory counts and pricing information for each of the barcodes ==========        // ----- order by updated date for processing        // ----- limit to inventory prior to the sales order date        // purchased inventory always has a purchase order with the price in it        // adjusting inventory down has an adjustment record - but price doesn't matter - its just gone (matters for year-end slippage)        // adjusting inventory up has an adjustment record - which will use the last pricing it can determine - has price in it        // get the part_cost as a default if it has not been purchased in the history                        $this->Inventory_In_Arr     = array();      // instantiate array that will hold all inbound inventory        $this->Inventory_Out_Arr    = array();      // instantiate array that will hold all outbound inventory                foreach ($this->Inventory_Salesorder_Sent_Arr AS $barcode => $array) {                        // ----- initialize blank values into array - keeps errors from happening later            $this->Inventory_In_Arr[$barcode][] = array(                'date'          => '1881-11-16',                'qty_in'        => 0,                'cost'          => 0,                'qty_used'      => 0,            );            $this->Inventory_Out_Arr[$barcode][] = array(                'date'          => '1881-11-16',                'qty_out'       => 0,            );                        $unset_inventory_in     = true;     // on first stored record - delete this fake record            $unset_inventory_out    = true;     // on first stored record - delete this fake record                                    // ----- get the max date for this barcode - so we don't pull inventory items passed this invoice            // ----- NOTE :: Currently disabled in actual query            $date_so_line = $array[0]['date_max'];                                    // ----- get the INs and OUTs of barcode inventory            /*			$Obj_InventoryMovements             = new Inventory_BarcodeSummaryReport();            $Obj_InventoryMovements->Barcode    = $barcode;            $Obj_InventoryMovements->Date       = $DATE;            $records                            = $Obj_InventoryMovements->GetInventoryMovements();            */						$records = $this->GetInventoryMovements($barcode, $DATE);			// call to InventoryBase for this						                        // ----- DEBUG VARIABLES -----            if (false) {                echo "<div style='border:5px solid green;'>";                $this->EchoVar('BARCODE', $barcode);                $this->EchoVar('RECORDS', $records);                echo "</div>";            }                    foreach ($records as $record) {                								// ----- PROCESS THE RECORD - DETERMINE ITS TYPE - How was this inventory brought into the system				$type       = '';				$type       = ($record['ref_purchase_orders_received_id'] != 0)   ? 'purchaseorder'   : $type;				$type       = ($record['ref_adjustment_id'] != 0)                 ? 'adjustment'      : $type;				$type       = ($record['ref_sales_order_sent_id'] != 0)           ? 'salesorder'      : $type;				$type       = ($record['ref_assembly_build_id'] != 0)             ? 'assembly'        : $type;				                				switch($type) {    										case 'purchaseorder':						$method_text 		= "purchase order";								// method the inventory change was made with						$method_id          = $record['ref_purchase_orders_received_id'];	// method ID the inventory change was made with						$date				= $record['IN_DATE'];							// date the inventory change was made on                                                $price_total        = $record['IN_PRICE_TOTAL'];                        $shipping_total     = $record['IN_PRICE_SHIPPING_TOTAL'];					break;										case 'adjustment':						$method_text 		= "inventory adjustment";						// method the inventory change was made with						$method_id          = $record['ref_adjustment_id'];					// method ID the inventory change was made with						$date				= $record['ADJ_DATE'];                          // date the inventory change was made on						                        $price_total        = $record['ADJ_PRICE_TOTAL'];                        $shipping_total     = $record['ADJ_PRICE_SHIPPING_TOTAL'];					break;										case 'salesorder':						$method_text 		= "sales order";								// method the inventory change was made with						$method_id          = $record['ref_sales_order_sent_id'];			// method ID the inventory change was made with						$date				= $record['OUT_DATE'];							// date the inventory change was made on						                        $price_total        = 0;                        $shipping_total     = 0;					break;										case 'assembly':						$method_text 		= "assembly build";								// method the inventory change was made with						$method_id          = $record['ref_assembly_build_id'];				// method ID the inventory change was made with						$date				= $record['ASSY_DATE'];							// date the inventory change was made on						                        $price_total        = $record['ASSY_PRICE_TOTAL'];  // (BAD - actually have to calculate value)                        $shipping_total     = 0;					break;										default:						$error = "Unable to determine inventory movement method";						$this->AddError($this->Classname, __FUNCTION__, $error);						$this->EchoError($this->Classname, __FUNCTION__, $error);						exit();					break;				}												                // ----- determine the actual INBOUND cost for this item                $quantity               = $record['qty_in'] + $record['qty_out'];                   // can't be both inbound and outbound inventory - so this gives correct quantity                 $cost_each_default      = $record['DEFAULT_PRICE_EACH'];                            // default cost for barcode                                $price_total            = ($price_total > 0) ? $price_total : $cost_each_default;   // set to default_cost if no stored value                $shipping_total         = ($shipping_total > 0) ? $shipping_total : 0;              // make sure there's a value for shipping (even if $0)                                $cost_total             = $price_total + $shipping_total;                           // calculate total price                $cost_each              = ($cost_total / $quantity);                                // calcualte each price                                                                if ($record['qty_in'] > 0) {                                        // remove the blank record being stored                    if ($unset_inventory_in) {                        unset($this->Inventory_In_Arr[$record['barcode']][0]);                        $unset_inventory_in = false;                    }                                        // store the actual record                    $this->Inventory_In_Arr[$record['barcode']][] = array(                        'date'          => $date,                        'qty_in'        => $record['qty_in'],                        'cost_each'     => $cost_each,                        'cost_total'    => $cost_total,                        'qty_used'      => 0,                        'method'        => $method_text,                        'method_id'     => $method_id,                        'description'   => "{$record['retailer_code']}<br />{$record['description']}",                    );                }                                if ($record['qty_out'] > 0) {                                        // ----- remove the blank record being stored                    if ($unset_inventory_out) {                        unset($this->Inventory_Out_Arr[$record['barcode']][0]);                        $unset_inventory_out = false;                    }                                        // ----- store the actual record                    $this->Inventory_Out_Arr[$record['barcode']][] = array(                        'date'                              => $date,                        'qty_out'                           => $record['qty_out'],                        'out_inventory_sales_orders_id'     => $record['out_inventory_sales_orders_id'],                        'method'                            => $method_text,                        'method_id'                         => $method_id,                        'description'                       => "{$record['retailer_code']}<br />{$record['description']}",                    );                }            }        } // end foreach $this->Inventory_Salesorder_Sent_Arr    }        public function GetInventoryValues_Average($BARCODE_ARR, $DATE='')    {        # FUNCTION :: use the value handling classes to determine the average value for each barcode.                if (!$BARCODE_ARR) {			$error = "No BARCODE_ARR passed into function";            $this->AddError($this->Classname, __FUNCTION__, $error);            $this->EchoError($this->Classname, __FUNCTION__, $error);            exit();		}                        $value_arr = array();                                              // instantiate array that will hold all barcode values                foreach ($BARCODE_ARR AS $barcode => $array) {                        // ----- check to see if already got value for this barcode - if so - don't do it again            if (!in_array($barcode, $value_arr)) {                                $Obj_ValueHandler                           = new Inventory_Valuation_ValueHandler();               // instantitate value class                $Obj_ValueHandler->Barcode                  = $barcode;                                             // pass in the barcode we want value for                $Obj_ValueHandler->Execute();                                                                       // execute the function to get value                $value_array                                = $Obj_ValueHandler->Value_Array;                       // store the value array for report processing                $value_each                                 = $Obj_ValueHandler->Value_Each;                        // value for a single instance of this barcode                $method_used                                = $Obj_ValueHandler->Value_Method_Used;                 // actual method used                unset($Obj_ValueHandler);                                                                           // memory cleanup                                $value_arr[$barcode] = array(                    'barcode'       => $barcode,                    'value_each'    => $value_each,                    'value_array'   => $value_array,                    'method_used'   => $method_used,                );                                            }			        } // end foreach $this->Inventory_Salesorder_Sent_Arr                return $value_arr;    }                public function CreateCOGSArray_FIFO($INVENTORY_SALES_ORDERS_ID=0)    {        # FUNCTION :: Loops through the quantity arrays and removed inventory being used        #             Also calcualtes the value of that inventory being removed and returns it - this calculation        #             can be used to determine value of sales order or ignored if just removing inventory counts.		#        # INVENTORY_SALES_ORDERS_ID = Sales order ID that should be calculated and COGS returned                if (!$INVENTORY_SALES_ORDERS_ID) {			$error = "No INVENTORY_SALES_ORDERS_ID passed into function";            $this->AddError($this->Classname, __FUNCTION__, $error);            $this->EchoError($this->Classname, __FUNCTION__, $error);            exit();		}		                		$report_lines   = '';           // initialize variable - will be passed to report generation class        $return_arr     = array();      // initialize variable - will hold the return COGS values                // ----- DEBUG VARIABLES -----        if (false) {            // ----- show the base array information that will be worked on -----            echo "<div style='border:1px solid red; padding:10px;'>";            $this->EchoVar('INVENTORY_SALES_ORDERS_ID', $INVENTORY_SALES_ORDERS_ID);			$this->EchoVar('SO_Number', $this->SO_Number);            $this->EchoVar('Inventory_Salesorder_Sent_Arr', $this->Inventory_Salesorder_Sent_Arr);            $this->EchoVar('Inventory_Out_Arr', $this->Inventory_Out_Arr);            $this->EchoVar('Inventory_In_Arr', $this->Inventory_In_Arr);            echo "</div>";        }                                                        // ----- loop through each barcode used in this salesorder -----        foreach ($this->Inventory_Salesorder_Sent_Arr AS $barcode => $arr) {                        //$this->EchoVar('barcode', $barcode);                        // ----- loop through each record that has this barcode going out of inventory -----            if (isset($this->Inventory_Out_Arr[$barcode])) {                            // ----- process each record of inventory going out -----                foreach ($this->Inventory_Out_Arr[$barcode] AS $idx => $record_out) {                                            $total_left_to_remove   		= $record_out['qty_out'];        // get the total we need to take out of inventory for a given barcode                    $removal_date           		= $record_out['date'];           // get date of inventory removal (can't remove inventory after this date)                    $out_inventory_sales_orders_id	= isset($record_out['inventory_sales_orders_id']) ? $record_out['inventory_sales_orders_id'] : 0;                    					###$this->EchoVar('A:: out_inventory_sales_orders_id', $out_inventory_sales_orders_id);                                        if (false) {                        echo "<br /><br />";                        $this->EchoVar('barcode', $barcode);                        $this->EchoVar('total_left_to_remove', $total_left_to_remove);                        $this->EchoVar('out_inventory_sales_orders_id', $out_inventory_sales_orders_id);                        //$this->EchoVar('Inventory_In_Arr', $this->Inventory_In_Arr);                    }                                        // ----- loop through the IN array and remove the out quantity                    foreach ($this->Inventory_In_Arr[$barcode] AS $id => $record) {                                                                        ###$this->EchoVar('rec', $this->Inventory_In_Arr[$barcode]);                                                ###$this->EchoVar('@@ barcode', $barcode);                        ///if ($barcode == 10110) {                        if ($total_left_to_remove > 0) {                                                        ###$this->EchoVar('total_left_to_remove', $total_left_to_remove);                                                        // ----- determine if inventory was in system prior to this out date                            // ----- if not its a critical failure that must be fixed first                            //$record['date'] = date("Y-m-d");                            if ($record['date'] > $removal_date) {                                $passed     = false;                                $error      = "Inventory does not exist in system as of the date trying to remove. As of <b>({$removal_date})</b> there needs to be <b>({$total_left_to_remove})</b> more in inventory for barcode <b>({$barcode})</b>.";                                $this->AddError($this->Classname, __FUNCTION__, $error);                                                                if ($out_inventory_sales_orders_id == $SO_NUMBER) {                                    $report_lines .= "<tr><td>{$barcode}</td><td>{$record['description']}</td><td colspan='6'>{$error}</td></tr>";                                }                                                                $this->COGS_Report = $this->MakeCOGSReport($report_lines);                                return false;                            }                                                        // ----- determine how many are still available in this record                            $cur_available_in_record = $record['qty_in'] - $record['qty_used'];                                                        if (false) {                                echo "<br /><br />";                                $this->EchoVar('qty_in', $record['qty_in']);                                $this->EchoVar('qty_used', $record['qty_used']);                                $this->EchoVar('cur_available_in_record', $cur_available_in_record);                            }                                                                                        ###$this->EchoVar('cur_available_in_record', $cur_available_in_record);                            if ($cur_available_in_record >= $total_left_to_remove) {                                                                                                // ----- have enough in this record to account for all OUT                                $new_qty_used               = $record['qty_used'] + $total_left_to_remove;          // mark record as partialy or totally used up                                $line_quantity              = $total_left_to_remove;                                $cogs                       = $line_quantity * $record['cost_each'];                // calculate COGS for this line                                $total_left_to_remove       = 0;                                                    // adjust that all of this barcode has been removed                                $this->Inventory_In_Arr[$barcode][$id]['qty_used'] = $new_qty_used;                 // store the values                            /*if ($out_inventory_sales_orders_id == $SO_NUMBER) {    echo "<br />AAAAAAAAAA";}*/                                                        } else {                                // ----- DO NOT have enough in this record to account for all OUT                                $new_qty_used               = $record['qty_in'];                                    // mark record as totally used up                                $line_quantity              = $cur_available_in_record;                                $cogs                       = $line_quantity * $record['cost_each'];                // calculate COGS for this line                                $total_left_to_remove       = $total_left_to_remove - $cur_available_in_record;     // adjust how much left to remove                                                                if ($this->Unset_Array_When_Used) {                                    // ----- blow out the array element if we've used up all the qty - speeds up future array checks                                    unset($this->Inventory_In_Arr[$barcode][$id]);                                }                                /*if ($out_inventory_sales_orders_id == $SO_NUMBER) {    echo "<br />BBBBBBBBBBBBB";}*/                                                            }                                                        // ----- calculate the COGS value for this barcode - if its the sales order we want                            if (false) {                                $this->EchoVar('out_inventory_sales_orders_id', $out_inventory_sales_orders_id);                                $this->EchoVar('INVENTORY_SALES_ORDERS_ID', $INVENTORY_SALES_ORDERS_ID);                                $this->EchoVar('cogs', $cogs);                                //$this->EchoVar('ra[bc]', $return_arr[$barcode]);                            }                                                                                    if ($line_quantity > 0) {                                if ($out_inventory_sales_orders_id == $INVENTORY_SALES_ORDERS_ID) {                                                                                                            ###$this->EchoVar('##### barcode', $barcode);                                                                        // ----- store the COGS value for the return array                                    $return_arr[$barcode] = isset($return_arr[$barcode]) ? ($return_arr[$barcode] + $cogs) : $cogs;                                                                                                                                                //$this->EchoVar('BB:: record in', $record);                                                                        // ----- add a line to the COGS report table                                    $cogs_each      = money_format('%n', $record['cost_each']);                                    $cogs_total     = money_format('%n', $cogs);                                    $date_parts     = explode(" ", $record['date']);                                    $date           = $date_parts[0];                                                                        $report_lines .= "                                        <tr>                                            <td>{$barcode}</td>                                            <td>{$record['description']}</td>                                            <td>{$line_quantity}</td>                                            <td>{$cogs_each}</td>                                            <td>{$cogs_total}</td>                                            <td>{$date}</td>                                            <td>{$record['method']}</td>                                            <td>{$record['method_id']}</td>                                        </tr>                                        ";                                } // end verifying this COGS value is associate with Sales Order                            } // end checking line quantity > 0                                                                                } // end if loop                        ///} // delete this *****                    } // end foreach loop                                        //$this->EchoVar('total_left_to_remove', $total_left_to_remove);                                                            // ----- check if enough inventory still in the inventory pool                    // ----- we have removed all inventory from the IN array - but there's still more                    if ($total_left_to_remove > 0) {                        $passed = false;                        $error = "Not enough inventory available to remove. Barcode: {$barcode}. Left to Remove: {$total_left_to_remove}.";                        $this->AddError($this->Classname, __FUNCTION__, $error);                        $this->COGS_Report = $this->MakeCOGSReport($report_lines);                    }                                                        } // end foreach            } else {                $passed = false;                $error = "BARCODE NOT FOUND IN INVENTORY - Barcode: <b>{$barcode}</b>";                $this->AddError($this->Classname, __FUNCTION__, $error);                            } // end if        } // end foreach                        if (false) {            $this->EchoVar('return_arr', $return_arr);        }                        // ----- make the COGS report        $this->COGS_Report = $this->MakeCOGSReport($report_lines);                                return $return_arr;    }    public function CreateCOGSArray_Average($BARCODE_ARR=0, $VALUE_ARR=0)    {        # FUNCTION :: Determine value of COGS through 'average' method                if (!$BARCODE_ARR) {			$error = "No BARCODE_ARR passed into function";            $this->AddError($this->Classname, __FUNCTION__, $error);            $this->EchoError($this->Classname, __FUNCTION__, $error);            exit();		}                if (!$VALUE_ARR) {			$error = "No VALUE_ARR passed into function";            $this->AddError($this->Classname, __FUNCTION__, $error);            $this->EchoError($this->Classname, __FUNCTION__, $error);            exit();		}                        $Obj_Summary    = new Inventory_Valuation_ValueSummaryReport();         // instantiate new value report        $report_lines   = '';                                                   // initialize variable - will be passed to report generation class        $return_arr     = array();                                              // initialize variable - will hold the return COGS values                // ----- DEBUG VARIABLES -----        if (false) {            // ----- show the base array information that will be worked on -----            echo "<div style='border:1px solid red; padding:10px;'>";            $this->EchoVar('BARCODE_ARR', $BARCODE_ARR);			$this->EchoVar('SO_Number', $this->SO_Number);            $this->EchoVar('Inventory_Salesorder_Sent_Arr', $this->Inventory_Salesorder_Sent_Arr);            $this->EchoVar('Inventory_Out_Arr', $this->Inventory_Out_Arr);            $this->EchoVar('Inventory_In_Arr', $this->Inventory_In_Arr);            echo "</div>";        }        //$this->EchoVar('BARCODE_ARR', $BARCODE_ARR);                        // ----- loop through each barcode used in this salesorder -----        foreach ($BARCODE_ARR AS $barcode => $arr)         {            // ----- calculate the total quantity used in the sales order            $quantity_total = 0;            foreach ($arr as $rec) {                $quantity_total += $rec['qty_out'];            }                                    $value_arr          = $VALUE_ARR[$barcode];                        #$this->EchoVar('barcode', $barcode);            #$this->EchoVar('value_arr', $value_arr);                                    // ----- calculate the COGS calue            $quantity           = $quantity_total;            $value_each         = $value_arr['value_each'];            $value_total        = ($value_each * $quantity);            $cogs_each          = money_format('%n', $value_each);            $cogs_total         = money_format('%n', $value_total);                                    // ----- store the COGS value for the return array            $return_arr[$barcode] = isset($return_arr[$barcode]) ? ($return_arr[$barcode] + $value_total) : $value_total;                                    // ----- get other information needed for report line            $date               = '-';            $line_quantity      = $quantity;            $description        = $this->GetInventoryItemDescriptionFromBarcode($barcode);                        $class              = $value_arr['value_array']['class'];            $method             = $value_arr['method_used'];            $method_details     = ($this->Show_Method_Details) ? ArrayToStr($value_arr['value_array']['method_details']) : '';                        $is_assembly        = $this->CheckIfAssembly($barcode);            $assembly_text      = ($is_assembly) ? 'YES' : '';                                    // ----- OUTPUT THE MAIN REPORT LINES            $report_lines .= "                <tr>                    <td>{$barcode}</td>                    <td>{$description}</td>                    <td>{$line_quantity}</td>                    <td>{$cogs_each}</td>                    <td>{$cogs_total}</td>                    <td>{$date}</td>                    <td>{$class}<br /><b>{$method}</b>{$method_details}</td>                    <td>{$assembly_text}</td>                </tr>                ";                                    // ----- OUTPUT THE ASSEMBLY DETAILS - IF ENABLED            if ($is_assembly && $this->Show_Assembly_Details) {                                $value_array_temp = $value_arr['value_array'];                $value_array_temp['method_details'] = $value_arr['value_array']['method_details'];                                $Obj_Summary->Barcode           = $barcode;                                             // barcode we're creating report for                $Obj_Summary->Value_Array       = $value_array_temp;                $Obj_Summary->Sub_Report        = true;                $sub_report                     = $Obj_Summary->Execute();                                $report_lines .= "<tr><td></td><td colspan='7'>{$sub_report}</td></tr>";                                            }                    } // end foreach                        if (false) {            $this->EchoVar('return_arr', $return_arr);        }                unset($Obj_Summary);    // memory cleanup                        // ----- make the COGS report        $this->COGS_Report = $this->MakeCOGSReport($report_lines);                                        return $return_arr;    }                    public function OutputCOGS($VALUE)    {        $date = date("Y-m-d H:i:s (e)");        $info = "            <div style='font-size:14px;'>            <table>            <tr><td align='right'><b>Sales Order Number:</b></td><td>{$this->SO_Number}</td></tr>            <tr><td align='right'><b>COGS:</b></td><td>{$VALUE}</td></tr>            <tr><td align='right'><b>Selected Pricing Method:</b></td><td>{$this->Pricing_Method_Used}</td></tr>            <tr><td align='right'><b>Report Generated Timestamp:</b></td><td>{$date}</td></tr>            </table>            </div>            ";        $title = "{$this->Classname} :: OutputCOGS()";        $output = $this->EchoInformation($title, $info, 'black', false);                return $output;    }        public function OutputCOGSHeader($VALUE, $TITLE='')    {        $date = date("Y-m-d H:i:s (e)");        $output = "            <div style='border:2px solid #000; font-size:14px;'>                <div style='padding:5px; background-color:#e3e3e3; font-weight:bold;'>{$TITLE}</div>                <div style='padding:5px;'>                    <table>                    <tr><td align='right'><b>Sales Order Number:</b></td><td>{$this->SO_Number}</td></tr>                    <tr><td align='right'><b>COGS:</b></td><td>{$VALUE}</td></tr>                    <tr><td align='right'><b>Selected Pricing Method:</b></td><td>{$this->Pricing_Method_Used}</td></tr>                    <tr><td align='right'><b>Report Generated Timestamp:</b></td><td>{$date}</td></tr>                    </table>                </div>            </div>            ";                    return $output;    }        public function MakeCOGSReport($LINES)    {        switch ($this->Method) {            case 'average':                                // ----- strip off previous query modification                global $PAGE;                $pagelink               = $PAGE['pagelinkquery'];                $pagelink               = str_replace(array('&methoddetails=false','&methoddetails=true'), '', $pagelink);                $pagelink               = str_replace(array('&assemblydetails=false','&assemblydetails=true'), '', $pagelink);                                // ----- determine what variables are currently triggered - and make sure they are used in other links                $link_method_current    = ($this->Show_Method_Details) ? '&methoddetails=true' : '&methoddetails=false';                $link_assembly_current  = ($this->Show_Assembly_Details) ? '&assemblydetails=true' : '&assemblydetails=false';                                // ----- create the link for showing/hiding methods                $link_method_on         = "<a href='{$pagelink}&methoddetails=true{$link_assembly_current}'>View Details</a>";                $link_method_off        = "<a href='{$pagelink}&methoddetails=false{$link_assembly_current}'>Hide Details</a>";                $link_method            = ($this->Show_Method_Details) ? $link_method_off : $link_method_on;                                // ----- create the link for showing/hiding assemblies                $link_assembly_on       = "<a href='{$pagelink}&assemblydetails=true{$link_method_current}'>View Details</a>";                $link_assembly_off      = "<a href='{$pagelink}&assemblydetails=false{$link_method_current}'>Hide Details</a>";                $link_assembly          = ($this->Show_Assembly_Details) ? $link_assembly_off : $link_assembly_on;                                $header = "                    <tr>                        <th>Barcode</th>                        <th>Description</th>                        <th>QTY From Inventory</th>                        <th>COGS / Each</th>                        <th>COGS / Total</th>                        <th>-</th>                        <th>Value Method ({$link_method})</th>                        <th>Assembly ({$link_assembly})</th>                    </tr>";            break;                        case 'fifo':                $header = "                    <tr>                        <th>Barcode</th>                        <th>Description</th>                        <th>QTY From Inventory</th>                        <th>COGS / Each</th>                        <th>COGS / Total</th>                        <th>Date Of Inventory INTO Inventory</th>                        <th>Inbound Inventory Type</th>                        <th>Inbound Inventory Ref #</th>                    </tr>";            break;        }                                                        $output = "            <table border='1' id='jsonTable'>                {$header}                {$LINES}                <tr>                    <td colspan='8'>                        <ul>                        <li>COGS values shown are rounded resulting in difference between each and total COGS. Final COGS value for sales order is rounded after summing all non-rounded COGS values.</li>                        <li>There may be multiple entries for a given barcode. This indicates inventory items were withdrawn from multiple inventory inputs.</li>                        </ul>                            </td>                </tr>            </table>";                        return $output;    }        public function CalculateTotalCOGS($ARR)    {        # FUNCTION :: Claculate the total COGS - and return it formatted for report                $total_cogs = 0;        foreach ($ARR AS $value) {            $total_cogs += $value;        }        $total_cogs = money_format('%n', $total_cogs);                return $total_cogs;    }        public function CheckIfAssembly($barcode)    {        // Check if this item is a sub-assembly                $records = $this->SQL->GetArrayAll(array(            'table' => 'inventory_assemblies',            'keys'  => 'inventory_assemblies_id',            'where' => "barcode='{$barcode}' AND active=1"        ));        $this->EchoQuery();                $is_subassembly = ($records) ? 1 : 0;        return $is_subassembly;    }                private function CreateFakeInArray()    {        $arr = Array(                '20008' => Array(                        '0' => Array(                                'date' => '2012-10-01 00:00:00',                                'qty_in' => '50',                                'cost' => '0.50',                                'qty_used' => '0',                            ),                    ),                '20081' => Array(                        '0' => Array(                                'date' => '2012-10-01 00:00:00',                                'qty_in' => '5',                                'cost' => '0.25',                                'qty_used' => '0',                            ),                        '1' => Array(                                'date' => '2012-10-02 00:00:00',                                'qty_in' => '5',                                'cost' => '1.25',                                'qty_used' => '0',                            ),                        '2' => Array(                                'date' => '2012-10-03 00:00:00',                                'qty_in' => '50',                                'cost' => '1.50',                                'qty_used' => '0',                            ),                    ),            );                    return $arr;    }    private function CreateFakeOutArray()    {        $arr = Array(                '20008' => Array(                        '0' => Array(                                'date' => '2012-11-01 00:00:00',                                'qty_out' => '5',                            ),                    ),                '20081' => Array(                        '0' => Array(                                'date' => '2012-11-01 00:00:00',                                'qty_out' => '2',                            ),                        '1' => Array(                                'date' => '2012-11-02 00:00:00',                                'qty_out' => '7',                            ),                        '2' => Array(                                'date' => '2012-11-03 00:00:00',                                'qty_out' => '1',                            ),                        '3' => Array(                                'date' => '2012-11-04 00:00:00',                                'qty_out' => '1',                            ),                        '4' => Array(                                'date' => '2012-11-05 00:00:00',                                'qty_out' => '1',                            ),                    ),            );                /*        # condense the array        $arr2 = array();        foreach ($arr AS $barcode => $array) {            foreach ($array AS $id => $record) {                $existing_qty   = isset($arr2[$barcode]['qty_out']) ? $arr2[$barcode]['qty_out'] : 0;                $new_qty        = $existing_qty + $record['qty_out'];                                $arr2[$barcode] = array(                    'qty_out'  => $new_qty,                );            };        };        */                        return $arr;    }        private function CreateFakeSalesOrderArray()    {        $arr = Array(                '20008' => Array(                        '0'=> Array(                                'date' => '2012-11-10 00:00:00',                                'qty_out' => '16',                            ),                    ),                '20081' => Array(                        '0' => Array(                                'date' => '2012-11-10 00:00:00',                                'qty_out' => '7',                            ),                        '1' => Array(                                'date' => '2012-11-10 00:00:00',                                'qty_out' => '2',                            ),                    ),            );                    return $arr;    }        }  // -------------- END CLASS --------------