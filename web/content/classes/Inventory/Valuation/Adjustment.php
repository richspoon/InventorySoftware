<?phpclass Inventory_Valuation_Adjustment extends Inventory_InventoryBase{    public $Show_Query                  = false;        public $Inventory_Adjustments_ID    = 0;    public $Date                        = 0;    public $Quantity                    = 0;    public $Barcode                     = 0;        public $COGS_Method                 = 'total_average';       // running_average || nearest_item || total_average    public $Running_Average_Days        = 30;            public $Use_Adjustment              = true;                 // allow raw adjsutments to count for COGS calculations    public $Use_Purchaseorder           = true;                 // allow purchase orders to count for COGS calculations            // ----- OUTPUT VARIABLES -----    public $COGS                        = 0;    public $COGS_Array                  = array();            public function  __construct()    {        parent::__construct();                $this->Classname = get_class($this);        $this->ClassInfo = array(            'Created By'    => 'Richard Witherspoon',            'Created Date'  => '2013-01-13',            'Updated By'    => 'Richard Witherspoon',            'Updated Date'  => '2013-02-24',            'Filename'      => $this->Classname,            'Version'       => '2.0',            'Description'   => 'Calculate the COGS for an adjustment record.',            'Update Log'    => array(                '2013-01-11_1.0'    => "Module Created",                '2013-02-21_1.1'    => "Modified CalculateCogs_TotalAverage() to handle new database fields",                '2013-02-24_2.0'    => "Significant resturcturing of all inventory valuation methodology.",            ),        );            } // -------------- END __construct --------------            /* ====== P-CODE ======================================================        An adjustment has no record of what parts came in through raw inventory.    The best we can do is determine raw parts cost + labor on the day of the adjustment    If this is a multi-tiered adjustment (actually an assembly item) this class isn't used - instead    we use the COGSAssembly() class which may instantitate another verison of this.        ==================================================================== */            public function Execute()    {        if (!$this->Inventory_Adjustments_ID)   {   echo "<br />ERROR :: {$this->Classname} :: Execute() :: Missing Inventory_Adjustments_ID"; exit();  }                $record         = $this->GetInventoryAdjustment($this->Inventory_Adjustments_ID);      // get the adjustment record        $this->Barcode  = $record['barcode'];                                                   // set the barcode        $this->Date     = $record['date'];                                                      // set the date                if (!$this->Date)       {   echo "<br />ERROR :: {$this->Classname} :: Execute() :: Missing Date";        }        if (!$this->Barcode)    {   echo "<br />ERROR :: {$this->Classname} :: Execute() :: Missing Barcode";     }        if (!$this->Quantity)   {   echo "<br />ERROR :: {$this->Classname} :: Execute() :: Missing Quantity";    }                        $is_assembly = $this->CheckIfSubAssembly($this->Barcode);                if ($is_assembly) {            //$this->EchoVar("THIS IS AN ASSEMBLY. Barcode: {$this->Barcode}");            ##$Obj_Handler = new Inventory_COGSHandler();            ##$Obj_Handler->Execute();            //$Obj_Assy = new Inventory_COGSAssembly();                        $Obj_Assy = new Inventory_AssemblyExplode();            $Obj_Assy->Barcode      = $this->Barcode;            $Obj_Assy->Quantity     = 1; //$this->Quantity;            $Obj_Assy->Execute();                        //$this->EchoVar('Obj_Assy->BOM', $Obj_Assy->BOM);            $cogs = 0;            $cogs_arr = array();            foreach ($Obj_Assy->BOM as $barcode => $qty) {                $cog_local = $this->CalculateCogs_TotalAverage($barcode);                $cogs += $cog_local;                $cogs_arr[$barcode] = array(                    'quantity'  => $qty,                    'cogs'      => $cog_local,                );            }                        $this->COGS  += $cogs;            $this->COGS_Array   = array(                'type' => 'Assembly Adjustment',                 'class' => 'Inventory_COGSAdjustment',                'BOM_Array' => $cogs_arr,            );                    } else {            // ----- we are at a RAW inventory item - calculate its value            $this->COGS  += $this->CalculateCogs();            $this->COGS_Array   = array();        }            }                public function CalculateCogs()    {        # FUNCTION :: DETERMINE THE ACTUAL COGS                switch($this->COGS_Method) {            case 'total_average':                //$this->EchoVar('total_average');                $cogs = $this->CalculateCogs_TotalAverage();            break;                        case 'running_average':                //$this->EchoVar('running_average');                $cogs = $this->CalculateCogs_RunningAverage();            break;                        case 'nearest_item':                //$this->EchoVar('nearest_item');                $cogs = $this->CalculateCogs_NearestItem();            break;                        default:                //$this->EchoVar('default');                $cogs = 0;            break;        }                return $cogs;    }        public function CalculateCogs_TotalAverage($barcode=0)    {        # FUNCTION :: DETERMINE THE ACTUAL COGS - Using a total average of all INBOUND inventory                $barcode = ($barcode != 0) ? $barcode : $this->Barcode;                $records = $this->GetInventoryMovements($barcode);        //$this->EchoVar('records', $records);                $use_adjustment     = $this->Use_Adjustment;        // allow raw adjsutments to count for COGS calculations        $use_purchaseorder  = $this->Use_Purchaseorder;     // allow purchase orders to count for COGS calculations        $cogs               = 0;        $cogs_qty           = 0;                foreach ($records as $record) {                        if ($record['qty_in'] > 0) {                // ----- initialize variables                $price_total            = 0;                $price_each             = 0;                $price_shipping_total   = 0;                                // ----- pull information from the database record                if (($record['ref_purchase_orders_received_id'] != 0) && $use_purchaseorder) {                    $price_total            = $record['IN_PRICE_TOTAL'];                    $price_each             = $record['IN_PRICE_EACH'];                    $price_shipping_total   = $record['IN_PRICE_SHIPPING'];                }                                // ----- pull information from the database record                if (($record['ref_adjustment_id'] != 0) && $use_adjustment) {                    $price_total            = $record['ADJ_PRICE_TOTAL'];                    $price_each             = $record['ADJ_PRICE_EACH'];                                        $ship_total             = $record['ADJ_PRICE_SHIPPING_TOTAL'];                    $ship_each              = $record['ADJ_PRICE_SHIPPING_EACH'];                }                                // ----- calculate the actual price                $qty_total              = $record['qty_in'];                $price_each             = ($price_each)     ? $price_each   : ($price_total / $qty_total);                $price_ship_each        = ($ship_each)      ? $ship_each    : ($ship_total / $qty_total);                                // ----- store the COGS information                $cogs += $price_each + $price_ship_each;                $cogs_qty++;                                $this->COGS_Array[] = array(                    'inventory_counts_id'   => $record['inventory_counts_id'],                    'cogs_each'             => $cogs,                    'date'                  => $record['date'],                );            }        }                        // ----- calculate the total average        if ($cogs && $cogs_qty) {            $cogs = ($cogs / $cogs_qty);        }                return $cogs;    }                    # ===== START :: UNDEVELOPED FUNCTIONS =====    public function CalculateCogs_RunningAverage()    {        # FUNCTION :: DETERMINE THE ACTUAL COGS - Using a time-based average                //$this->Running_Average_Days                return 0;    }        public function CalculateCogs_NearestItem()    {        # FUNCTION :: DETERMINE THE ACTUAL COGS - By finding the closest item by date (in past)                return 0;    }    # ===== END :: UNDEVELOPED FUNCTIONS =====                    public function GetInventoryAdjustment($inventory_adjustments_id)    {        $record = $this->SQL->GetRecord(array(            'table' => 'inventory_adjustments',            'keys'  => '*',            'where' => "inventory_adjustments_id='{$inventory_adjustments_id}' AND active=1",        ));        $this->EchoQuery();                return $record;    }        public function CheckIfSubAssembly($barcode)    {        // Check if this item is a sub-assembly                $records = $this->SQL->GetArrayAll(array(            'table' => 'inventory_assemblies',            'keys'  => 'inventory_assemblies_id',            'where' => "barcode='{$barcode}' AND active=1"        ));        $this->EchoQuery();                $is_subassembly = ($records) ? 1 : 0;        return $is_subassembly;    }        }  // -------------- END CLASS --------------