<?phpclass Inventory_Valuation_InventoryAssemblyCalculateValue extends Inventory_InventoryBase{    public $Show_Query                  = false;    public $Barcode                     = 0;        public $Cogs_Total                  = 0;    public $Cogs_Array                  = array();        /* ===========================    Guiding Rule :: Assembly COGS should ONLY be calculated - never use stored DB value - go to the raw parts used + labor        This class uses the COGSHandler() functions to determine the COGS of each item making up a given assembly    =========================== */            public function  __construct()    {        parent::__construct();        $this->SetSQLInventory();   // set the database connection to the inventory database                $this->Classname = get_class($this);        $this->ClassInfo = array(            'Created By'    => 'Richard Witherspoon',            'Created Date'  => '2013-01-11',            'Updated By'    => 'Richard Witherspoon',            'Updated Date'  => '2013-02-26',            'Filename'      => $this->Classname,            'Version'       => '2.0',            'Description'   => 'Calculate value of assemblies.',            'Update Log'    => array(                '2013-01-11_1.0'    => "Module Created",                '2013-02-26_2.0'    => "Significant restructuring of all inventory valuation methodology.",            ),        );            } // -------------- END __construct --------------                        public function Execute()    {        # FUNCTION :: Determine the value of all the inventory of this type - KNOWN TO BE ASSEMBLIES                // ----- GET all inventory movements for this barcode        //$records = $this->GetInventoryMovements($this->Barcode);                        if (!$this->Barcode) {              $error = "Missing Barcode";            $this->AddError($this->Classname, __FUNCTION__, $error);            $this->EchoError($this->Classname, __FUNCTION__, $error, true);            exit();        }                        $Obj_TEMP           = new Inventory_GetRecordUsedOnDate();        $Obj_TEMP->Barcode  = $this->Barcode;                        $records = $Obj_TEMP->GetInventoryMovements();      // get all the inbound and outbound inventory movements for given barcode(s)        $Obj_TEMP->ExplodeMovements($records);              // make each barcode movement take up one line - and additional processing        $Obj_TEMP->CreateInOutMatchedArray();               // match up inventory movements - creates new array(s)                        $count_available    = count($Obj_TEMP->Inventory_Available);        $sku                = $this->GetInventoryItemRetailerCodeFromBarcode($this->Barcode);                        if (true) {            echo "<br />INVENTORY IN / OUT<br />" .             $this->ConvertArrayToTable($this->Inventory_All);            echo "<br />INVENTORY IN<br />" .                   $this->ConvertArrayToTable($this->Inventory_In);            echo "<br />INVENTORY OUT<br />" .                  $this->ConvertArrayToTable($this->Inventory_Out);            echo "<br />DATE ARRAY<br />" .                     $this->ConvertArrayToTable($this->Inventory_In_Out_Date);            echo "<br />INVENTORY IN - OUT COMBINED<br />" .    $Obj_TEMP->ConvertArrayToTable($Obj_TEMP->Inventory_In_Out_Matched);            echo "<br />INVENTORY AVAILABLE<br />" .            $Obj_TEMP->ConvertArrayToTable($Obj_TEMP->Inventory_Available);        }                                // ----- CREATE ARRAY OF ALL INVENTORY RECORDS TO CALCUALTE (these are the actual invnetory records)        // ----- NOTE :: $Obj_TEMP->Inventory_Available :: Contains the avialable inventory (not used up already)        $inventory_counts_id_arr = array();        foreach ($Obj_TEMP->Inventory_Available as $record) {            $barcode    = $record['barcode'];            $icid       = $record['inventory_counts_id_in'];            $count      = (isset($inventory_counts_id_arr[$icid])) ? $inventory_counts_id_arr[$icid] : 0;                        $inventory_counts_id_arr[$icid] = $count + 1;        }                                //unset($inventory_counts_id_arr[1722]);                                // ----- FOR EACH INVENTORY RECORDS - PROCESS THROUGH COGS HANDLER        // ----- this will get what the actual COGS is for this database item        // ----- NOTE :: If they're from the same inventory_counts_id - must get COGS at same time or        // -----         there can be an issue on the formula math.                $cogs_total     = 0;        $cogs_array     = array();                foreach ($inventory_counts_id_arr as $inventory_counts_id => $qty) {                        // ----- Instantiate the handler object            $Obj_Handler = new Inventory_COGSHandler();            $Obj_Handler->Inventory_Counts_ID   = $inventory_counts_id;            $Obj_Handler->Quantity              = $qty;            $Obj_Handler->Execute();                        // ----- store the COGS information returned            $cogs_icid = $Obj_Handler->COGS; //$Obj_Handler->COGS_Single;            $cogs_total += $cogs_icid;                        $cogs_array[] = array(                'inventory_counts_id'   => $inventory_counts_id,                'qty'                   => $qty,                'cogs_total'            => $cogs_icid,            );                        if (true) {                echo "<br /><br /><div style='border:1px solid green; padding:10px; margin:10px;'>";                $this->EchoVar('COGS_Array', $Obj_Handler->COGS_Array);                echo "</div>";            }        }                                                if (true) {            echo "<br /><br /><div style='border:5px solid red; padding:10px; margin:10px;'>";            $this->EchoVar("{$this->Classname} :: Execute()", 'DUMPING FINAL ASSESSMENTS');            $this->EchoVar('BARCODE', $this->Barcode);            $this->EchoVar('INVENTORY AVAILABLE', $count_available);            $this->EchoVar('Actual Database Records To Check (inventory_counts_id_arr)', $inventory_counts_id_arr);            $this->EchoVar('Result of gathering COGS (cogs_array)', $cogs_array);            $this->EchoVar('COGS_Total', $cogs_total);            echo "</div>";        }                $this->Cogs_Array = $cogs_array;        $this->Cogs_Total = $cogs_total;                return $cogs_total;    }            public function _Execute($inventory_assembly_build_id)    {        $final_arr = $this->CalculateAssemblyValue_BuildTable($inventory_assembly_build_id);                        // ----- process final value of inventory assembly -----        $cogs_subassembly = 0;        foreach ($final_arr as $id => $record) {            $real               = (isset($record['cogs_real']) && $record['cogs_real'] > 0) ? $record['cogs_real'] : 0;            $caculated          = (isset($record['cogs_calculated']) && $record['cogs_calculated'] > 0) ? $record['cogs_calculated'] : 0;            $cogs_subassembly   = $cogs_subassembly + $real + $caculated;        }                        $this->EchoVar('cogs_subassembly', $cogs_subassembly);        echo "<br />LAST STEP";                        #$cogs_temp = $this->CalculateInventoryValue($barcode, $date, true);        #$this->EchoVar('', '');        #$this->EchoVar('barcode', $barcode);        #$this->EchoVar('cogs_temp', $cogs_temp);                                $obj_tz = new Inventory_GetRecordUsedOnDate();        #$obj_tz->Barcode = $barcode;        #$obj_tz->Date = $date;        $obj_tz->Execute();                //exit();                        return $final_arr;    }            public function CalculateAssemblyValue_BuildTable($inventory_assembly_build_id)    {        # FUNCTION :: Calculate value of a record in the inventory_assembly_build table                /* P-CODE ==================                1. Get the build record from the database table        2. Get a comparison record for the build from the assembly table                3. Determine if anything inside selected array is also a sub-assembly - if YES - get those records        4. Check if the build record matches current assembly table record - if NOT - might be ok                5. Build up a complete analysis of all original barcodes needed (no assemblies) with the dates they were pulled from system        6. Calculate the value                ========================= */                                // ----- get the build record we're trying to value        $record_build               = $this->GetInventoryAssemblyBuildRecord($inventory_assembly_build_id);        $build_record_build         = unserialize($record_build['build_record_array']);        //$build_record_build         = $this->FakeBuildRecord();                                               // FAKE FOR TESTING                // ----- get assembly lines records        $inventory_assemblies_id    = $record_build['inventory_assemblies_id'];        $records_assembly_lines     = $this->GetAssemblyRecord($inventory_assemblies_id);                        // ----- create the build record from assembly lines        $Obj                        = new Inventory_InventoryAssemblyBuild();        $build_record_current       = unserialize($Obj->CreateBuildRecord($records_assembly_lines));        //$build_record_current[]     = array('barcode' => 666, 'quantity_out'=>9, 'quantity_in'=>0);         // FAKE FORCE FAIL                        /*        // ----- compare the two arrays to see if build differs        $build_record_build_diff    = $this->SimplifyArrayForDiff($build_record_build);        $build_record_current_diff  = $this->SimplifyArrayForDiff($build_record_current);        $build_record_match         = ($build_record_build_diff == $build_record_current_diff) ? true : false;                if (!$build_record_match) {            echo "<br />Build records DO NOT match";            #$this->EchoVar('build_record_build', $build_record_build);            #$this->EchoVar('build_record_current', $build_record_current);        }        */                        // ----- modify any parts of the build records for further processing        $build_record_build         = $this->AddDateToAssemblyArray($build_record_build, $record_build['date']);    // add date information to array        $build_record_build         = $this->AddSubassemblyToAssemblyArray($build_record_build);                    // add sub-assembly status to array        $build_record_build         = $this->AddSKUInformationToAssemblyArray($build_record_build);                 // add info about the SKU being used        $build_record_build         = $this->AddValuePlaceholderToAssemblyArray($build_record_build);               // add placeholder info about the value of iventory item        $build_record_build         = $this->ProcessLines($build_record_build);                             // process sub-assemblies to ge their records                        // ----- must return the array because of recursive calls        return $build_record_build;    }            public function ProcessLines($ARR)    {        # FUNCTION :: Check each barcode in the BOM and determine if its actually another subassembly        #             which then needs to be pulled - and continue until no more sub-assemblies found.        #             All this function does is build up a complete array of assemblies                # NOTE :: Later it needs to also track the dates that each level was done (for getting price later)                        //$this->EchoVar('CheckForSubAssemblies (ARR) :: START ::', $ARR);                foreach ($ARR as $id => $record) {            $barcode            = $record['barcode'];            $date               = $record['date'];            $quantity           = $record['quantity_in'] + $record['quantity_out'];     // can't be both in and out - so sum gives you true quantity            $is_subassembly     = $record['is_subassembly'];                                    // ----- DETERMINE INVENTORY USED            // ----- Given a certain date - what inbound inventory item(s) would have been used for this - that is the COGS            // ----- If its an assembly - this will drive us to discover what assembly build record was used            if ($quantity > 0) {                $Obj_Item                   = $this->RequestInventoryItemOnDate($barcode, $quantity, $date);                $inventory_counts_id_arr    = $Obj_Item->GetInventoryCountsID();    // array of inventory_counts_id used                $inventory_cogs             = $Obj_Item->GetCogs();                 // calculated COGS - for non-asembly items (is ASSY - COGS will = 0)            } else {                $inventory_counts_id_arr = array();                $inventory_cogs = 0;            }                        if ($is_subassembly) {                // it is a sub-assembly so need to go deeper                // get an inventory item from inventory on the correct date (date important because of varying price of inbound hardware)                // from the inventory item we just got - get that item's assembly record (if have one) - get the details of that assembly record                // if we don't have a record (maybe added from inventory adjustment) use the currently stored assembly record                                                foreach ($inventory_counts_id_arr as $inventory_counts_id) {                    // ----- figure out what assembly build ID was used to create this item                    $record_temp                    = $this->GetInventoryCountsRecord($inventory_counts_id);                    $inventory_assembly_build_id    = (isset($record_temp['ref_assembly_build_id'])) ? $record_temp['ref_assembly_build_id'] : 0;                                        if ($inventory_assembly_build_id) {                                                // This inventory item is actually another assembly. Need to go get its sub-assembly details and process                         // that before we can continue in the current assembly.                        // RECURSIVE CALLBACK                        $ARR[$id]['subassembly'] = $this->CalculateAssemblyValue_BuildTable($inventory_assembly_build_id);                                            } else {                        // NO BUILD RECORD FOUND - EVEN THOUGH THIS IS AN ASSEMBLY                        // load the assemblies that could make this barcode - if more than one use the default one                                                $recs_assy                  = $this->GetInventoryAssembliesFromBarcode($barcode);                   // get all possible assemblies                        $inventory_assemblies_id    = $this->GetDefaultInventoryAssembliesID($recs_assy);                   // determine the assembly to use                        $records_assembly_lines     = $this->GetAssemblyRecord($inventory_assemblies_id);                   // get the lines used for this assembly                        $Obj                        = new Inventory_InventoryAssemblyBuild();                               // instantiate object to convert to build record                        $build_record_default       = unserialize($Obj->CreateBuildRecord($records_assembly_lines));        // create build record                                                $build_record_default       = $this->AddDateToAssemblyArray($build_record_default, $date);          // add date information to array                        $build_record_default       = $this->AddSubassemblyToAssemblyArray($build_record_default);          // add sub-assembly status to array                        $build_record_default       = $this->AddSKUInformationToAssemblyArray($build_record_default);       // add info about the SKU being used                        $build_record_default       = $this->AddValuePlaceholderToAssemblyArray($build_record_default);     // add info about the value of iventory item                        $build_record_default       = $this->ProcessLines($build_record_default);                   // process sub-assemblies to ge theri records                                                $ARR[$id]['subassembly_error']      = "UNABLE TO LOAD ASSEMBLY RECORD - USING DEFAULT BUILD RECORD - inventory_assemblies_id: {$inventory_assemblies_id}";                        $ARR[$id]['subassembly']            = $build_record_default;                    }                }                                                                // ----- now we have fully processed this sub-assembly (maybe recursively) - so calculate its COGS                $ARR[$id]['cogs_calculated'] = $this->CalculateSubassemblyCOGS($ARR[$id]['subassembly']);                                            } else {                $value = $inventory_cogs;     //1.11;                $ARR[$id]['cogs_real'] = $value;            }                        //$ARR[$id]['inv_avail'] = $Obj_Item->Inventory_Available;        }                //$this->EchoVar('CheckForSubAssemblies (ARR) :: END ::', $ARR);                return $ARR;    }            public function RequestInventoryItemOnDate($barcode, $quantity, $date)    {        # FUNCTION :: Get the actual barcode items used on this date - so its the true price                /* +++++++++++++++++++++++++++++++++++++                MAYBE USE THE SALES ORDER FUNCTION FOR THIS                +++++++++++++++++++++++++++++++++++++ */                $Obj                = new Inventory_GetRecordUsedOnDate();        $Obj->Barcode       = $barcode;     //10000;        $Obj->Date          = $date;        //'2012-11-21';        $Obj->Quantity      = $quantity;    //1        $Obj->Record_Type   = 'assembly';        $Obj->Execute();                return $Obj;    }        public function CheckIfSubAssembly($barcode)    {        // Check if this item is a sub-assembly                $records = $this->SQL->GetArrayAll(array(            'table' => 'inventory_assemblies',            'keys'  => 'inventory_assemblies_id',            'where' => "barcode='{$barcode}' AND active=1"        ));        $this->EchoQuery();                $is_subassembly = ($records) ? 1 : 0;        return $is_subassembly;    }            public function FakeBuildRecord()    {        $return_arr = array();        $return_arr[] = array(                'barcode'       => 10053,                'quantity_in'   => 1,                'quantity_in'   => 0,            );        return $return_arr;    }        public function AddDateToAssemblyArray($ARR, $DATE)    {        # FUNCTION :: Add the date infomrmation to the build array        foreach ($ARR as $id => $record) {            $parts = explode(" ", $DATE);            $ARR[$id]['date'] = $parts[0];        }                return $ARR;    }        public function AddSubassemblyToAssemblyArray($ARR)    {        # FUNCTION :: Add sub-assembly information to each record        foreach ($ARR as $id => $record) {            $is_subassembly = $this->CheckIfSubAssembly($record['barcode']);            $ARR[$id]['is_subassembly'] = $is_subassembly;        }                return $ARR;    }        public function AddValuePlaceholderToAssemblyArray($ARR)    {        # FUNCTION :: Add price place-holder information to each record        # Note : initialize to -1 as a cehck later that all rows have been properly processed for price                foreach ($ARR as $id => $record) {            if (!$record['is_subassembly']) {                $ARR[$id]['cogs_real']          = -1;   // will hold real cost (only for physical inventory);            } else {                $ARR[$id]['cogs_calculated']    = -1;   // will hold calculated cost of all sub-assembly (physical inventory) parts            }        }                return $ARR;    }        public function AddSKUInformationToAssemblyArray($ARR)    {        # FUNCTION :: Add SKU information to the array        foreach ($ARR as $id => $record) {            $rec                        = $this->GetInventoryRecordFromBarcode($record['barcode']);            $ARR[$id]['sku']            = $rec['retailer_code'];            //$ARR[$id]['description']    = $rec['description'];        }                return $ARR;    }        public function SimplifyArrayForDiff($ARR)    {        # FUNCTION :: Combine barcode records for simpler array comparison. A build record in system could         #             have multiple lines using same barcode which would throw off comparison.                //$this->EchoVar('ARR', $ARR);                $output_arr = array();        foreach ($ARR as $id => $record) {                        $quantity_orig          = (isset($output_arr['barcode'])) ? $output_arr['barcode'] : 0;            $barcode                = $record['barcode'];            $quantity_new           = $record['quantity_out'] - $record['quantity_in'];            $quantity               = $quantity_orig + $quantity_new;                        $output_arr[$barcode]   = $quantity;        }                return $output_arr;    }        public function CalculateSubassemblyCOGS($ARR)    {        $cogs_subassembly = 0;        foreach ($ARR as $id => $record) {                        $real               = (isset($record['cogs_real']) && $record['cogs_real'] > 0) ? $record['cogs_real'] : 0;            $caculated          = (isset($record['cogs_calculated']) && $record['cogs_calculated'] > 0) ? $record['cogs_calculated'] : 0;            $cogs_subassembly   = $cogs_subassembly + $real + $caculated;        }        return $cogs_subassembly;    }        public function GetAssemblyRecord($inventory_assemblies_id)    {        $records = $this->SQL->GetArrayAll(array(            'table' => " inventory_assembly_lines",            'keys'  => "*",            'where' => "`inventory_assemblies_id`='{$inventory_assemblies_id}' AND active=1",        ));        $this->EchoQuery();        return $records;    }        public function GetInventoryCountsRecord($inventory_counts_id)    {        $record = $this->SQL->GetRecord(array(            'table' => 'inventory_counts',            'keys'  => 'ref_assembly_build_id, ref_purchase_orders_received_id, ref_adjustment_id',            'where' => "inventory_counts_id='{$inventory_counts_id}' AND active=1",        ));        $this->EchoQuery();        return $record;    }        public function GetInventoryAssemblyBuildRecord($inventory_assembly_build_id)    {        $record = $this->SQL->GetRecord(array(            'table' => 'inventory_assembly_build',            'keys'  => 'inventory_assemblies_id, inventory_assembly_build_id, build_record_array, date',            'where' => "inventory_assembly_build_id='{$inventory_assembly_build_id}' AND active=1",        ));        $this->EchoQuery();        return $record;    }        public function GetInventoryAssembliesFromBarcode($barcode)    {        # Note : default must be wrapped in tick marks or query will fail - its a protected MySQL word                $records = $this->SQL->GetArrayAll(array(            'table' => 'inventory_assemblies',            'keys'  => 'inventory_assemblies_id, `default`',            'where' => "barcode='{$barcode}' AND active=1",        ));        $this->EchoQuery();        return $records;    }        public function GetDefaultInventoryAssembliesID($ARR)    {        // ----- multiple build records for this barcode - determine the default build to use        // ----- will use the first record found if no default        $default_id     = 0;        $default_found  = false;        if (count($ARR) > 1) {            foreach ($ARR as $id2 => $rec_assy_build) {                if ($rec_assy_build['default'] == 1) {                                        // ----- check for multiple defaults                    if ($default_found == true) {                        echo "<br />ERROR :: Inventory_InventoryAssemblyCalculateValue :: ProcessLines() :: Multiple default assemblies found";                        exit();                    }                                        $default_id     = $id2; //$rec_assy_build['inventory_assemblies_id'];                    $default_found  = true;                }            }            //$this->EchoVar('ARR', $ARR);        }                $inventory_assemblies_id    = $ARR[$default_id]['inventory_assemblies_id'];        return $inventory_assemblies_id;    }                                    }  // -------------- END CLASS --------------