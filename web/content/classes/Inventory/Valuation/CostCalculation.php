<?phpclass Inventory_Valuation_CostCalculation extends BaseClass       // don't need functions from InventoryBase plus makes smaller memory footprint{    public $Show_Query                      = false;    public $Barcode                         = 0;    public $Date                            = '';    public $Method                          = 'total_average';  // is the 'preferred' method to calculate cost    public $Classname                       = "";        public $Value_Array                     = array();    public $Price_Calculated_Each           = 0;    public $Price_Calculated_Shipping_Each  = 0;    public $Used_Default_Value              = 0;        // if returns 1 - means the default value was used    public $Used_Method                     = '';       // will store what method was finally used to get cost    public $Build_Record                    = array();  // if this turns out to be an assembly - it will store assy record used            public function  __construct()    {        parent::__construct();                $this->Classname = get_class($this);        $this->ClassInfo = array(            'Created By'    => 'Richard Witherspoon',            'Created Date'  => '2013-01-23',            'Updated By'    => 'Richard Witherspoon',            'Updated Date'  => '2013-02-24',            'Filename'      => $this->Classname,            'Version'       => '2.0',            'Description'   => 'Functions used to determine the cost of an item - usually when making an adjustment.',            'Update Log'    => array(                '2013-01-23_001'    => "Module Created",                '2013-02-24_2.0'    => "Significant restructuring of all inventory valuation methodology.",            ),        );                $this->Date = date('Y-m-d');            } // -------------- END __construct --------------        public function Pseudocode()    {        # FUNCTION :: Pseudocode for this class. Returned here as a variable so it can be dumped to the screen for review.                $output = "        ==========================================================================        [$this->Classname :: Pseudocode()]        ==========================================================================                [Description]:        Determine how much an item should cost when being added to the system. This often         happens when making an inventory adjustment - we don't have a real price so we need to know what         the system thinks the cost should be. If this was a purchase order - we would know the exact price.                [Methods]:        total_average = Takes all inventory items ever purchased (or inbound) and averages cost        fifo = Functionality not implemented                [To Do List]:        Implement the 'fifo' method        ";                $search     = array('[', ']');        $replace    = array('<b>', '</b>');        $output     = str_replace($search, $replace, $output);      // special formatting        $output     = nl2br($output);                               // create line breaks                return $output;    }            public function Execute()    {                /* ===== P-CODE =======================================================        Check if assembly        if assembly - get assy pricing        if not assembly - get barcode pricing        If can't derive from these methods - fall back to default cost        ==================================================================== */                switch ($this->Method) {            case 'total_average':                $result                 = 0;                                                                        // initialize result - which stores 1 if a cost can be determined                $this->Used_Method      = 'total_average';                                                          // initialize method used                $is_assembly            = $this->CheckIfSubAssembly($this->Barcode);                                // determine if barcode is an assembly                                if ($is_assembly) {                    $barcode            = $this->Barcode;                                                           // set the barcode - even though function can figure it out                    $build_record       = '';                                                                       // we have no known build record - it will be determined in next function                    $result             = $this->CalculatePrice_Assembly_TotalAverage($barcode, $build_record);     // calculate value                    $this->Used_Method  = 'assembly_total_average';                                                 // set status of what method actually used                } else {                    $barcode            = $this->Barcode;                                                           // set the barcode - even though function can figure it out                    $result             = $this->CalculatePrice_Barcode_TotalAverage($barcode);                     // calculate value                    $this->Used_Method  = 'barcode_total_average';                                                  // set status of what method actually used                                    // ----- FAILED TO GET ANY COST FOR ITEM                    if (!$result) {                        $barcode            = $this->Barcode;                                                       // set the barcode - even though function can figure it out                        $result             = $this->CalculatePrice_Barcode_DefaultCost($barcode);                  // get default value                        $this->Used_Method  = 'default_value';                                                      // set status of what method actually used                    }                }                                $output = $result;            break;                        case 'fifo':                $result                 = 0;                                                                        // initialize result - which stores 1 if a cost can be determined                $this->Used_Method      = 'fifo';                                                                   // initialize method used                $is_assembly            = $this->CheckIfSubAssembly($this->Barcode);                                // determine if barcode is an assembly                                if ($is_assembly) {                    $barcode            = $this->Barcode;                                                           // set the barcode - even though function can figure it out                    $build_record       = '';                                                                       // we have no known build record - it will be determined in next function                    $date               = $this->Date;                                                              // set the date inventory being calculated for                    $result             = $this->CalculatePrice_Assembly_FIFO($barcode, $build_record, $date);      // calculate value                    $this->Used_Method  = 'assembly_fifo';                                                          // set status of what method actually used                } else {                    $barcode            = $this->Barcode;                                                           // set the barcode - even though function can figure it out                    $date               = $this->Date;                                                              // set the date inventory being calculated for                    $result             = $this->CalculatePrice_Barcode_FIFO($barcode, $date);                      // calculate value                    $this->Used_Method  = 'barcode_fifoe';                                                          // set status of what method actually used                                        // ----- FAILED TO GET ANY COST FOR ITEM                    if (!$result) {                        $barcode            = $this->Barcode;                                                       // set the barcode - even though function can figure it out                        $result             = $this->CalculatePrice_Barcode_DefaultCost($barcode);                  // get default value                        $this->Used_Method  = 'default_value';                                                      // set status of what method actually used                    }                }                                $output = $result;            break;                        default:                $this->EchoVar('ERROR', "{$this->Classname} :: Execute :: No Method provided.". 'red');                $output = 0;                //exit();            break;        }                return $output;    }                public function CalculatePrice_Barcode_DefaultCost($barcode=0)    {        # FUNCTION :: Calculate the price for a new barcode item based on the logic of this function        #     NOTE :: Usually this is used when making an adjustment - to calculate value of each adjustment item. This should be last resort.        #   METHOD :: DefaultCost - Use the default cost stored for this barcode.                        $barcode                    = ($barcode != 0) ? $barcode : $this->Barcode;      // get barcode        $return                     = 0;                                                // initialize return variable        $this->Used_Default_Value   = 1;                                                // set status that we had to use default value                        if (!$barcode) {            $this->EchoVar('ERROR', "{$this->Classname} :: CalculatePrice_Barcode_DefaultCost :: No barcode provided.". 'red');            exit();        }                if ($barcode) {            // ----- get default value from database            $record = $this->SQL->GetRecord(array(                'table' => 'inventory_products',                'keys'  => '*',                'where' => "barcode='{$barcode}' AND active=1",            ));            $this->EchoQuery();                        if ($record) {                // ----- store the values -----                $this->Price_Calculated_Each            = $record['part_cost'];                $this->Price_Calculated_Shipping_Each   = 0;                $this->Value_Array[] = array(                    'default_cost'              => $record['part_cost'],                    'price_reference_source'    => $record['price_reference_source'],                    'price_reference_number'    => $record['price_reference_number'],                    'price_reference_date'      => $record['price_reference_date'],                    'price_reference_url'       => $record['price_reference_url'],                    'price_reference_price'     => $record['price_reference_price'],                    'price_reference_quantity'  => $record['price_reference_quantity'],                    'price_reference_notes'     => $record['price_reference_notes'],                );                                $return = 1;            }        }                return $return;    }        public function CalculatePrice_Barcode_TotalAverage($barcode=0)    {        # FUNCTION :: Calculate the price for a new barcode item based on the logic of this function        #     NOTE :: Usually this is used when making an adjustment - to calculate value of each adjustment item        #   METHOD :: TotalAverage - Takes an average of all physical purchases (purchase orders) in the system - no date restriction                $barcode = ($barcode != 0) ? $barcode : $this->Barcode;                if (!$barcode) {            $this->EchoVar('ERROR', "{$this->Classname} :: CalculatePrice_Barcode_TotalAverage :: No barcode provided.", 'red');            exit();        }                // ----- look at all purchase orders received to determine what inbound price is        /*        $records = $this->SQL->GetArrayAll(array(            'table' => 'inventory_counts',            'keys'  => 'inventory_counts.inventory_counts_id, inventory_counts.date AS IC_DATE, inventory_purchase_order_received.*',            'where' => "inventory_counts.barcode='{$barcode}' AND inventory_counts.qty_in > 0 AND inventory_counts.ref_purchase_orders_received_id != 0 AND inventory_counts.active=1",            'joins' => 'LEFT JOIN inventory_purchase_order_received ON inventory_purchase_order_received.inventory_purchase_order_received_id = inventory_counts.ref_purchase_orders_received_id',        ));        $this->EchoQuery();        */                $records = $this->SQL->GetArrayAll(array(            'table' => 'inventory_purchase_order_received',            'keys'  => '*',            'where' => "barcode='{$barcode}' AND quantity > 0 AND active=1",        ));        $this->EchoQuery();                                if (!$records) {            $this->EchoVar('ERROR', "{$this->Classname} :: CalculatePrice_Barcode_TotalAverage :: No records found for barcode. Barcode: {$barcode}");            return 0;        }                $this->Value_Array                      = array();        $this->Price_Calculated_Each            = 0;        $this->Price_Calculated_Shipping_Each   = 0;        $cost_sum                               = 0;        $cost_shipping_sum                      = 0;        $quantity_sum                           = 0;                foreach ($records as $record) {                        // ----- initialize variables            $price_total            = 0;            $price_each             = 0;            $price_shipping_total   = 0;            $price_shipping_each    = 0;                                    $price_total            = $record['price_total'];            $price_each             = $record['price_each'];            $price_shipping_total   = $record['price_shipping'];            $price_shipping_each    = $record['price_shipping_each'];                                    // ----- calculate the actual price            $qty_total              = $record['quantity'];            $price_each             = ($price_each) ? $price_each : ($price_total / $qty_total);            $price_ship_each        = ($price_shipping_each) ? $price_shipping_each : ($price_shipping_total / $qty_total);            $cost_part_total        = ($price_each * $qty_total);            $cost_shipping_total    = ($price_shipping_each * $qty_total);                        // ----- store the information            $cost_sum           += $cost_part_total;            $cost_shipping_sum  += $cost_shipping_total;            $quantity_sum       += $qty_total;                        $inventory_counts_id                    = isset($record['inventory_counts_id']) ? $record['inventory_counts_id'] : 0;            $inventory_purchase_order_received_id   = isset($record['inventory_purchase_order_received_id']) ? $record['inventory_purchase_order_received_id'] : 0;            $IC_DATE                                = isset($record['IC_DATE']) ? $record['IC_DATE'] : $record['date'];                        // ----- this helps us understnad how cost was calculated            $this->Value_Array[] = array(                'inventory_counts_id'                   => $inventory_counts_id,                'inventory_purchase_order_received_id'  => $inventory_purchase_order_received_id,                'date'                                  => $IC_DATE,                'quantity'                              => $qty_total,                #'calculated_cost_part_total'            => $cost_part_total,                #'calculated_cost_shipping_total'        => $cost_shipping_total,                'record_price_total'                    => $record['price_total'],                'record_price_each'                     => $record['price_each'],                'record_price_shipping_total'           => $record['price_shipping'],                'record_price_shipping_each'            => $record['price_shipping_each'],            );        }                        // ----- calculate the total average                $this->Price_Calculated_Each            = ($cost_sum / $quantity_sum);        $this->Price_Calculated_Shipping_Each   = ($cost_shipping_sum / $quantity_sum);                return 1;    }        public function CalculatePrice_Assembly_TotalAverage($barcode=0, $assembly_bom='')    {        # FUNCTION :: Calculate the price for a new assembly item based on the logic of this function        #     NOTE :: Usually this is used when making an adjustment - to calculate value of each adjustment item        #     NOTE :: For each barcode - if it can't get a calculated cost - it will go to the default velue        #   METHOD :: TotalAverage - Takes an average of all physical purchases (purchase orders) in the system - no date restriction        #   P-CODE :: Break apart each assembly item to its raw inventory barcode - then calculate the average for each barcode                        $assy_barcode   = ($barcode != 0) ? $barcode : $this->Barcode;        $return         = 1;        $show_debug     = false;                        if (!$assy_barcode) {            $this->EchoVar('ERROR', "{$this->Classname} :: CalculatePrice_Assembly_TotalAverage :: No assy_barcode provided.". 'red');            exit();        }                // ----- Check to see if we passed in a BOM or build record - use that        // ----- If no build record - get the default build record (by using the Inventory_AssemblyExplode Class)        if (!$assembly_bom) {            $Obj_Explode = new Inventory_AssemblyExplode();         // Instantiate the assembly explode class            $Obj_Explode->Barcode = $assy_barcode;                  // Set barcode for the assembly we want to explode            $Obj_Explode->Quantity = 1;                             // Set count for a single assembly            $Obj_Explode->Execute();                                // Run the function            $assembly_bom = $Obj_Explode->BOM;                      // Store the BOM for this assembly Array(barcode => quantity, barcode => quantity, etc...)        }                $this->Build_Record = $assembly_bom;                #$this->EchoVar('assembly_bom', $assembly_bom);        #exit();                $value_array_temp   = array();      // initialize temp array variable        $price_total_temp   = 0;        $ship_total_temp    = 0;                $sku = $this->GetInventoryItemRetailerCodeFromBarcode($assy_barcode);                if ($show_debug) {$this->EchoVar('', '<div style="border:1px solid green; padding:10px; margin:10px;">');}        if ($show_debug) {$this->EchoVar('Notice', 'BEGINNING LOOP', 'blue');}        if ($show_debug) {$this->EchoVar('Master Barcode', $assy_barcode);}        if ($show_debug) {$this->EchoVar('sku', $sku);}        if ($show_debug) {$this->EchoVar('assembly_bom', $assembly_bom);}                foreach ($assembly_bom as $barcode => $quantity) {                        if ($show_debug) {$this->EchoVar('', '');}            if ($show_debug) {$this->EchoVar('barcode', $barcode);}            if ($show_debug) {$this->EchoVar('quantity', $quantity);}                        $this->Value_Array  = array();                                          // reset the variable            $result = $this->CalculatePrice_Barcode_TotalAverage($barcode);         // Get the average cost for this barcode                        if (!$result) {                if ($show_debug) {$this->EchoVar('Notice', 'Trying for default value', 'blue');}                $result = $this->CalculatePrice_Barcode_DefaultCost($barcode);      // Get the default cost for this barcode                if ($result) {                    if ($show_debug) {$this->EchoVar('Notice', 'Default Value Found');}                }            }                        if ($result) {                                $price_total    = ($this->Price_Calculated_Each * $quantity);               // Calc total for this barcode given qty in assembly                $ship_total     = ($this->Price_Calculated_Shipping_Each * $quantity);      // Calc ship total for this barcode given qty in assembly                                $price_total_temp   += $price_total;                                        // Store value                $ship_total_temp    += $ship_total;                                         // Store value                $value_array_temp[$barcode] = $this->Value_Array;                           // Store the value_array for this barcode - shows how barcode cost was calculated                                if ($show_debug) {$this->EchoVar('Price Each', $this->Price_Calculated_Each);}                if ($show_debug) {$this->EchoVar('Ship Each', $this->Price_Calculated_Shipping_Each);}                if ($show_debug) {$this->EchoVar('Price Total', $price_total);}                if ($show_debug) {$this->EchoVar('Ship Total', $ship_total);}                            } else {                // ----- FAILED to get any cost for this barcode in assembly                $this->EchoVar('ERROR', "{$this->Classname} :: CalculatePrice_Assembly_TotalAverage :: Couldn't calculate average for barcode. Barcode: {$barcode} ", 'red');                $return = 0;    // any failure will cause this whole function to return FALSE (0)            }        }                if ($show_debug) { $this->EchoVar('', '</div>');}                $this->Price_Calculated_Each            = $price_total_temp;        $this->Price_Calculated_Shipping_Each   = $ship_total_temp;        $this->Value_Array                      = $value_array_temp;                return $return;    }                            public function CalculatePrice_Assembly_FIFO($barcode=0, $assembly_bom='', $date='')    {        echo "ERROR :: $this->Classname :: CalculatePrice_Assembly_FIFO() :: Function not implemented.";        exit();    }        public function CalculatePrice_Barcode_FIFO($barcode=0, $date='')    {        echo "ERROR :: $this->Classname :: CalculatePrice_Barcode_FIFO() :: Function not implemented.";        exit();    }                    public function CheckIfSubAssembly($barcode)    {        // Check if this item is a sub-assembly                $records = $this->SQL->GetArrayAll(array(            'table' => 'inventory_assemblies',            'keys'  => 'inventory_assemblies_id',            'where' => "barcode='{$barcode}' AND active=1"        ));        $this->EchoQuery();                $is_subassembly = ($records) ? 1 : 0;        return $is_subassembly;    }        public function GetInventoryItemRetailerCodeFromBarcode($BARCODE)    {        # FUNCTION :: Return retailer_code inventory item from barcode                $return = 'ERROR :: NO BARCODE PROVIDED';                if ($BARCODE) {            $record = $this->SQL->GetRecord(array(                'table' => 'inventory_products',                'keys'  => 'retailer_code',                'where' => "`barcode`='{$BARCODE}'",            ));            $this->EchoQuery();                        $return = ($record) ? $record['retailer_code'] : "ERROR :: INVENTORY ITEM NOT FOUND";                    }                return $return;    }        }  // -------------- END CLASS --------------